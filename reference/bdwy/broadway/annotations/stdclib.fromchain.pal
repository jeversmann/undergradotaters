%{

#include <stdio.h>
#include <stdlib.h>

#define __USE_GNU
#include <string.h>

#include <signal.h>
#include <math.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <utime.h>
#include <unistd.h>
#include <malloc.h>
#include <sys/stat.h>
#include <sys/times.h>
#include <sys/time.h>
#include <sys/uio.h>

#include <stdarg.h>
#include <syslog.h>
#include <time.h>
#include <unistd.h>
#include <fcntl.h>
#include <ctype.h>

#undef vscanf
#undef vfscanf
#undef vsscanf

extern int vscanf(const char * format, va_list args);
extern int vfscanf(FILE * f, const char * format, va_list args);
extern int vsscanf(char * str, const char * format, va_list args);

#include <errno.h>
#undef errno

#include <sys/utsname.h>
#include <netdb.h>

}%

#ifdef SHOW

#define SHOW_WRITE(buffer, IOHandle) \
  report if (FDKind : buffer is-atleast Unknown) \
    "WRITE: at " ++ @context ++ " data from " ++ FDKind : buffer ++ " (" ++ FDKind : buffer @ever ++ ") " ++ \
    " sent to " ++ FDKind : IOHandle ++ " (" ++ FDKind : IOHandle @ever ++ ")\n";

#define SHOW_NOHANDLE_WRITE(buffer, dest) \
  report if (FDKind : buffer is-atleast Unknown) \
    "WRITE: at " ++ @context ++ " data from " ++ FDKind : buffer ++ " (" ++ FDKind : buffer @ever ++ ") " ++ \
    " sent to " ++ dest ++ "\n";

#define SHOW_READ(IOHandle) \
  report "READ: at " ++ @context ++ ": read data from " ++ FDKind : IOHandle ++ " (" ++ FDKind : IOHandle @ever ++ ")" ++ \
    " determined by " ++ FDKind : name_object ++ " (" ++ FDKind : name_object @ever ++ ")\n";

#define SHOW_NOHANDLE_READ(src) \
  report "READ: at " ++ @context ++ ": read data from " ++ src ++ "\n";

#else

#define SHOW_WRITE(buffer, IOHandle)
#define SHOW_NOHANDLE_WRITE(buffer, dest)
#define SHOW_READ(IOHandle)
#define SHOW_NOHANDLE_READ(src)

#endif

// ------------------------------------------------------------
//  Globals
// ------------------------------------------------------------

global { I/O Disk }

global { asctime_static_buffer,
	 strerror_static_buffer
       }

global { errno }

// ------------------------------------------------------------
// Analysis properties
// ------------------------------------------------------------

property Taint : { Tainted { Untainted } }

property FDKind : { Unknown { File,
			      Socket { Unix { StandardIO },
				       Inet
				     },
			      Environment
			    }
		      }

property FDName : { Unknown { File,
			      Socket { Unix { StandardIO },
				       Inet
				     },
			      Environment
			    }
		      }

property FDState : { Unknown { Open { Read, Write },
			       Closed
			     }
		   }

property SocketKind : { Unknown { Stream,
				  Datagram,
				  Raw }
		      }

// -- Socket state: this lattice is optimistic; it assumes that library calls succeed.

property SocketState : { Connected { Listening { Bound { New }}}}

// --- Standard streams

global {

  stdin --> stdin_file_structure --> stdin_iohandle
  stdout --> stdout_file_structure --> stdout_iohandle
  stderr --> stderr_file_structure --> stderr_iohandle
}

analyze FDKind {
  stdin_iohandle <- StandardIO
  stdout_iohandle <- StandardIO
  stderr_iohandle <- StandardIO
}

analyze FDState {
  stdin_iohandle <- Read
  stdout_iohandle <- Write
  stderr_iohandle <- Write
}

// ------------------------------------------------------------
//  Error handling
// ------------------------------------------------------------

procedure __errno_location()
{
  on_exit {
    return --> errno
  }
}

procedure strerror(num)
{
  modify { strerror_static_buffer }
  on_exit {
    return --> strerror_static_buffer
  }
}

procedure perror(message)
{
  on_entry {
    message --> message_string
  }
  access { message_string }
  modify { Disk }
}

// ------------------------------------------------------------
// Environment
// ------------------------------------------------------------

procedure uname(buf)
{
  on_entry {
    buf --> struct_utsname { sysname --> sysname_contents
                             nodename --> nodename_contents
                             release --> release_contents
                             version --> version_contents
                             machine --> machine_contents
                             domainname --> domainname_contents }
  }

  modify { sysname_contents,
	     nodename_contents,
	     release_contents,
	     version_contents,
	     machine_contents,
	     domainname_contents }
}

procedure getpid() {}

procedure getppid() {}

procedure getuid() {}

procedure geteuid() {}

procedure getenv(name)
{
  on_entry {
    name --> name_string }

  access name_string
  modify value_string

  analyze Taint { value_string <- Tainted }

  analyze FDKind { value_string <- Environment }

  on_exit { return --> new value_string }

  report if (FDKind : name_string is-atleast Unknown)
    "Warning at " ++ @context ++ ": Read environment variable determined by " ++ FDKind : name_string ++
      "(" ++ FDKind : name_string @ever ++ ")\n";
}

procedure putenv(name)
{
  on_entry {
    name --> name_string }

  access name_string
}


procedure gettimeofday(tv, tz)
{
  on_entry {
    tv --> struct_timeval { tv_sec, tv_usec }
    tz --> struct_timezone { tz_minuteswest, tz_dsttime }
  }

  modify { struct_timeval.tv_sec,
	     struct_timeval.tv_usec,
	     struct_timezone.tz_minuteswest,
	     struct_timezone.tz_dsttime }
}


procedure time(timep)
{
  on_entry {
    timep --> the_time
  }

  modify { the_time }
}

procedure asctime(timeptr)
{
  on_entry {
    timeptr --> struct_tm { tm_sec         // seconds
                          tm_min         // minutes
                          tm_hour        // hours 
                          tm_mday        // day of the month
                          tm_mon         // month
                          tm_year        // year
                          tm_wday        // day of the week
                          tm_yday        // day in the year
                          tm_isdst       // daylight saving time
			}
  }

  access { struct_tm.tm_sec,
	     struct_tm.tm_min,
	     struct_tm.tm_hour,
	     struct_tm.tm_mday,
	     struct_tm.tm_mon,
	     struct_tm.tm_year,
	     struct_tm.tm_wday,
	     struct_tm.tm_yday,
	     struct_tm.tm_isdst }

  modify { asctime_static_buffer }

  on_exit {
    return --> asctime_static_buffer
  }
}

procedure ctime(timep)
{
  on_entry {
    timep --> the_time
  }

  access the_time
  modify time_string

  on_exit {
    return --> new time_string
  }
}

global { struct_tm_static_buffer }


procedure localtime(timep)
{
  on_entry {
    timep --> the_time
  }

  access { the_time }

  modify { struct_tm_static_buffer }

  on_exit {
    return --> struct_tm_static_buffer
  }

  /* This isn't right: there is only one buffer
  modify {struct_tm.tm_sec,
	    struct_tm.tm_min,
	    struct_tm.tm_hour,
	    struct_tm.tm_mday,
	    struct_tm.tm_mon,
	    struct_tm.tm_year,
	    struct_tm.tm_wday,
	    struct_tm.tm_yday,
	    struct_tm.tm_isdst }

  on_exit {
    return --> new struct_tm { tm_sec         // seconds
                               tm_min         // minutes
                               tm_hour        // hours 
                               tm_mday        // day of the month
                               tm_mon         // month
                               tm_year        // year
                               tm_wday        // day of the week
                               tm_yday        // day in the year
                               tm_isdst       // daylight saving time
			     }
  }
  */
}

procedure gmtime(timep)
{
  on_entry {
    timep --> the_time
  }

  access { the_time }

  modify { struct_tm_static_buffer }

  on_exit {
    return --> struct_tm_static_buffer
  }

  /* See note above
  modify {struct_tm.tm_sec,
	    struct_tm.tm_min,
	    struct_tm.tm_hour,
	    struct_tm.tm_mday,
	    struct_tm.tm_mon,
	    struct_tm.tm_year,
	    struct_tm.tm_wday,
	    struct_tm.tm_yday,
	    struct_tm.tm_isdst }

  on_exit {
    return --> new struct_tm { tm_sec         // seconds
                               tm_min         // minutes
                               tm_hour        // hours 
                               tm_mday        // day of the month
                               tm_mon         // month
                               tm_year        // year
                               tm_wday        // day of the week
                               tm_yday        // day in the year
                               tm_isdst       // daylight saving time
			     }
  }
  */
}

procedure mktime(timeptr)
{
  on_entry {
    timeptr --> struct_tm { tm_sec         // seconds
                          tm_min         // minutes
                          tm_hour        // hours 
                          tm_mday        // day of the month
                          tm_mon         // month
                          tm_year        // year
                          tm_wday        // day of the week
                          tm_yday        // day in the year
                          tm_isdst       // daylight saving time
			}
  }

  access { struct_tm.tm_sec,
	     struct_tm.tm_min,
	     struct_tm.tm_hour,
	     struct_tm.tm_mday,
	     struct_tm.tm_mon,
	     struct_tm.tm_year,
	     struct_tm.tm_wday,
	     struct_tm.tm_yday,
	     struct_tm.tm_isdst }
}

// ------------------------------------------------------------
//  Misc
// ------------------------------------------------------------

procedure exit(status)
{
  modify { Disk }
}

procedure atexit(function_ptr)
{
  on_entry { function_ptr --> function }
  access { function }
}

procedure abort() {}

procedure ferror(stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  access { IOHandle }
}

procedure feof(stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  access { IOHandle }
}

procedure fflush(stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { IOHandle, Disk }
}

procedure truncate(path, length)
{
  on_entry { path --> path_string }

  access { path_string }
  modify { Disk }
}

procedure ftruncate(fd, length)
{
  modify { Disk }
}

%{
#define _GNU_SOURCE
#include <getopt.h>
}%

global { optarg, optind, opterr, optopt }

procedure getopt(argc, argv, optstring)
{
  on_entry {
    argv --> argv_array --> arg
    optstring --> optstring_contents
  }

  access { arg, optstring_contents }
}

procedure getopt_long(argc, argv, optstring, longopts, longindex)
{
  on_entry {
    argv --> argv_array --> arg
    optstring --> optstring_contents
    longopts --> struct_option { name --> name_string,
				 has_arg,
				 flag --> flag_var,
				 val }
  }

  access { arg, optstring_contents, name_string, struct_option.has_arg,
	     flag_var, struct_option.val }

  modify { flag_var }
}

procedure getopt_long_only(argc, argv, optstring, longopts, longindex)
{
  on_entry {
    argv --> argv_array --> arg
    optstring --> optstring_contents
    longopts --> struct_option { name --> name_string,
				 has_arg,
				 flag --> flag_var,
				 val }
  }

  access { arg, optstring_contents, name_string, struct_option.has_arg,
	     flag_var, struct_option.val }

  modify { flag_var }
}

// ------------------------------------------------------------
//  Memory map
// ------------------------------------------------------------

%{

#include <sys/mman.h>

}%

procedure mmap(start, length, prot, flags, fd, offset)
{
  access { Disk }

  analyze Taint { file_buffer <- Tainted }

  analyze FDKind { file_buffer <- File }

  on_exit { return --> new file_buffer }
}

procedure munmap(buffer_ptr, length)
{
  on_entry { buffer_ptr --> buffer }
  access { Disk }
}

// ------------------------------------------------------------
//  File position
// ------------------------------------------------------------

procedure lseek(fd, offset, whence)
{
  on_entry { fd --> IOHandle }
  modify { IOHandle, Disk }
}

procedure fseek( stream, offset, whence)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { IOHandle, Disk }
}

procedure ftell( stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  access { IOHandle }
}

procedure rewind( stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { IOHandle, Disk }
}

procedure fgetpos( stream, pos_ptr)
{
  on_entry { stream --> file_structure --> IOHandle }
  access { IOHandle }
}

procedure fsetpos( stream, pos_ptr)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { IOHandle, Disk }
}

// ------------------------------------------------------------
//  File meta-information
// ------------------------------------------------------------

%{

#include <unistd.h>
#include <dirent.h>

}%

procedure readdir(dir)
{
  on_entry { dir --> dirent }

  analyze Taint { name_string <- Tainted } 

  analyze FDKind { name_string <- File }

  on_exit {
    return --> new struct_dirent { d_ino, d_off, d_reclen,
				   d_name --> new name_string }
  }

  modify { struct_dirent.d_ino, struct_dirent.d_off,
	     struct_dirent.d_reclen, name_string }
}

procedure opendir(name)
{
  on_entry { name --> name_string }
  access { name_string }
  modify { dir_entry }

  on_exit { return --> new dir_entry }
}

procedure closedir(dir)
{
  on_entry { dir --> dirent }
  access { dirent }
}


procedure stat(file_name, buf)
{
  on_entry {
    file_name --> file_name_string
    buf --> struct_stat { st_dev,
			    st_ino,
			    st_mode,
			    st_nlink,
			    st_uid,
			    st_gid,
			    st_rdev,
			    st_size,
			    st_blksize,
			    st_blocks,
			    st_atime,
			    st_mtime,
			    st_ctime }
  }

  access { file_name_string, Disk }
  modify { struct_stat.st_dev,
	     struct_stat.st_ino,
	     struct_stat.st_mode,
	     struct_stat.st_nlink,
	     struct_stat.st_uid,
	     struct_stat.st_gid,
	     struct_stat.st_rdev,
	     struct_stat.st_size,
	     struct_stat.st_blksize,
	     struct_stat.st_blocks,
	     struct_stat.st_atime,
	     struct_stat.st_mtime,
	     struct_stat.st_ctime }
}

procedure fstat(fd, buf)
{
  on_entry {
    buf --> struct_stat { st_dev,
			    st_ino,
			    st_mode,
			    st_nlink,
			    st_uid,
			    st_gid,
			    st_rdev,
			    st_size,
			    st_blksize,
			    st_blocks,
			    st_atime,
			    st_mtime,
			    st_ctime }
  }

  access { Disk }
  modify { struct_stat.st_dev,
	     struct_stat.st_ino,
	     struct_stat.st_mode,
	     struct_stat.st_nlink,
	     struct_stat.st_uid,
	     struct_stat.st_gid,
	     struct_stat.st_rdev,
	     struct_stat.st_size,
	     struct_stat.st_blksize,
	     struct_stat.st_blocks,
	     struct_stat.st_atime,
	     struct_stat.st_mtime,
	     struct_stat.st_ctime }
}

procedure lstat(file_name, buf)
{
  on_entry {
    file_name --> file_name_string
    buf --> struct_stat { st_dev,
			    st_ino,
			    st_mode,
			    st_nlink,
			    st_uid,
			    st_gid,
			    st_rdev,
			    st_size,
			    st_blksize,
			    st_blocks,
			    st_atime,
			    st_mtime,
			    st_ctime }
  }

  access { file_name_string, Disk }
  modify { struct_stat.st_dev,
	     struct_stat.st_ino,
	     struct_stat.st_mode,
	     struct_stat.st_nlink,
	     struct_stat.st_uid,
	     struct_stat.st_gid,
	     struct_stat.st_rdev,
	     struct_stat.st_size,
	     struct_stat.st_blksize,
	     struct_stat.st_blocks,
	     struct_stat.st_atime,
	     struct_stat.st_mtime,
	     struct_stat.st_ctime }
}

/*
procedure access(pathname, mode)
{
  on_entry { pathname --> pathname_string }

  access { pathname_string }
}
*/

procedure chmod(path, mode)
{
  on_entry {
    path --> path_string
    mode --> mode_string
  }
  access { path_string, mode_string }
  modify { Disk }
}

procedure fchmod(fd, mode)
{
  modify { Disk }
}

procedure utime(filename, buf)
{
  on_entry {
    filename --> filename_string
    buf --> struct_utimebuf
  }
  access { filename_string, Disk }
  modify { struct_utimebuf }
}

procedure chown(path, owner, group)
{
  on_entry {
    path --> path_string
  }
  access { path_string }
  modify { Disk }
}

procedure fchown(fd, owner, group)
{
  modify { Disk }
}

/*
procedure access(path, mode)
{
  on_entry {
    path --> path_string
  }
  access { path_string }
  modify { }
}

*/

procedure chdir(path)
{
  on_entry { path --> path_string }

  access { path_string }
  modify { Disk }
}

procedure fchdir(fd)
{
  on_entry { fd --> IOHandle }

  access { IOHandle }
  modify { Disk }
}

// ------------------------------------------------------------
//  File descriptor manipulation
// ------------------------------------------------------------

procedure fcntl(fd, cmd, arg)
{
  on_entry { fd --> IOHandle }

  modify { IOHandle }
}

%{

#include <sys/ioctl.h>

}%

procedure ioctl(fd, request, arg)
{
  on_entry { fd --> IOHandle }

  modify { IOHandle }
}


// ------------------------------------------------------------
// Open and close
// ------------------------------------------------------------

procedure fopen(path, mode)
{
  on_entry { path --> path_string { from --> path_from }
             mode --> mode_string  }
  access { path_string, mode_string }
  modify { Disk }
  on_exit { return --> new file_structure --> new IOHandle { from --> new from_object { from --> path_from }}

  analyze FDKind { IOHandle <- File }

  analyze FDState { IOHandle <- Open }

  report if (FDKind : path_string is-atleast Unknown)
    "Warning at " ++ @context ++ ": Opening a file specified by untrusted source " ++ FDKind : path_string ++
      " (" ++ FDKind : path_string @ever ++ ")\n";
}

procedure open(path, flags, mode)
{
  on_entry {  path --> path_string  }
  access { path_string }
  modify { Disk }
  on_exit { return --> new IOHandle { name --> path_string } }

  analyze FDKind { IOHandle <- File }

  analyze FDState { IOHandle <- Open }

  report if (FDKind : path_string is-atleast Unknown)
    "Warning at " ++ @context ++ ": Opening a file specified by untrusted source " ++ FDKind : path_string ++
      " (" ++ FDKind : path_string @ever ++ ")\n";
}


procedure fdopen(fd, mode)
{
  on_entry { fd --> IOHandle
             mode --> mode_string  }
  access { mode_string }
  modify { Disk }
  on_exit { return --> new file_structure --> IOHandle }

  analyze FDState { IOHandle <- Open }
}

procedure freopen(path, mode, stream)
{
  on_entry { path --> path_string
             mode --> mode_string
	     stream --> old_file_structure --> IOHandle { name --> old_path_string } }
  access { path_string, mode_string }
  modify { Disk }
  on_exit { return --> new file_structure --> IOHandle { name --> path_string }
	    delete old_file_structure }

  analyze FDKind { IOHandle <- File }

  analyze FDState { IOHandle <- Open }

  report if (FDKind : path_string is-atleast Unknown)
    "Warning at " ++ @context ++ ": Opening a file specified by untrusted source " ++ FDKind : path_string ++
      " (" ++ FDKind : path_string @ever ++ ")\n";
}

procedure umask(mask) {}

procedure creat(path, mode)
{
  on_entry {
    path --> path_string
  }
  access { path_string }
  modify { Disk }
}

procedure fclose(stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { Disk }
  on_exit { delete IOHandle
	    delete file_structure
	  }
}

procedure close( fd )
{
  on_entry { fd --> IOHandle }
  modify { Disk }
  on_exit { delete IOHandle }
}

procedure rename(old_path, new_path)
{
  on_entry {
    old_path --> old_path_string
    new_path --> new_path_string
  }

  access { old_path_string, new_path_string }
  modify { Disk }
}

procedure remove(path)
{
  on_entry {
    path --> path_string
  }
  access { path_string }
  modify { Disk }
}


procedure unlink(path)
{
  on_entry {
    path --> path_string
  }
  access { path_string }
  modify { Disk }
}

procedure fileno(stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { Disk }
  on_exit { return --> IOHandle }
}

// ------------------------------------------------------------
//  printf
// ------------------------------------------------------------

procedure printf(format, args)
{
  on_entry {
    format --> format_string
    args --> arg_contents
  }
  access { format_string, arg_contents }
  modify { Disk }

  SHOW_NOHANDLE_WRITE(arg_contents, "stdout")

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure fprintf(stream, format, args)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    format --> format_string
    args --> arg_contents
  }
  access { format_string, arg_contents }
  modify { IOHandle, Disk }

  SHOW_WRITE(arg_contents, IOHandle)

  report if ( ! FDState : IOHandle is-atleast Open)
    "Error at " ++ @context ++ ": file " ++ [stream] ++
      " is not open (state is " ++ FDState : IOHandle ++ ")\n";

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure sprintf(str, format, args)
{
  on_entry { str --> output_string
	     format --> format_string
	     args --> arg_contents }

  access { output_string, format_string, arg_contents }
  modify { output_string }

  analyze Taint { output_string <- arg_contents }

  analyze FDKind { output_string <- arg_contents }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure snprintf(str, size, format, args)
{
  on_entry { str --> output_string
	     format --> format_string
	     args --> arg_contents }

  access { output_string, format_string, arg_contents }
  modify { output_string }

  analyze Taint { output_string <- arg_contents }

  analyze FDKind { output_string <- arg_contents }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure vprintf(format, args)
{
  on_entry { format --> format_string
	     args --> arg_contents  }
  access { format_string, arg_contents }
  modify { Disk }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";

  SHOW_NOHANDLE_WRITE(arg_contents, "stdout")
}

procedure vfprintf(stream, format, args)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    format --> format_string
    args --> arg_contents
  }
  access { format_string, arg_contents }
  modify { IOHandle, Disk }

  SHOW_WRITE(arg_contents, IOHandle)

  report if ( ! FDState : IOHandle is-atleast Open)
    "Error at " ++ @context ++ ": file " ++ [stream] ++
      " is not open (state is " ++ FDState : IOHandle ++ ")\n";

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure vsprintf(str, format, args)
{
  on_entry {
    str --> output_string
    format --> format_string
    args --> arg_contents
  }
  access { output_string, format_string, arg_contents }
  modify { output_string }

  analyze Taint { output_string <- arg_contents }

  analyze FDKind { output_string <- arg_contents }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure vsnprintf(str, size, format, args)
{
  on_entry {
    str --> output_string
    format --> format_string
    args --> arg_contents
  }
  access { output_string, format_string, arg_contents }
  modify { output_string }

  analyze Taint { output_string <- arg_contents }

  analyze FDKind { output_string <- arg_contents }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " from source " ++ FDKind : format_string ++
    " at " ++ @context ++ "\n";

  report "TRACE at " ++ @context ++ " (" ++ FDKind : format_string @ever ++ ")\n" ++
    "TAINTED: \n" ++ Taint : format_string @trace ++ "\n" ++
    "SOURCE:\n" ++ FDKind : format_string @trace ++ "\n";
}

// ------------------------------------------------------------
//  scanf
// ------------------------------------------------------------

procedure scanf(format, args)
{
  on_entry {
    format --> format_string
    args --> arg_contents --> arg_refs
  }
  access { format_string, Disk }
  modify { arg_contents, arg_refs }

  analyze FDKind { arg_refs <- StandardIO }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";

  SHOW_NOHANDLE_READ("stdin")
}

procedure fscanf(stream, format, args)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    format --> format_string
    args --> arg_contents --> arg_refs
  }

  access { format_string, Disk }
  modify { arg_contents, arg_refs, IOHandle }

  analyze FDKind { arg_refs <- IOHandle }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";

  SHOW_READ(IOHandle)
}

procedure sscanf(str, format, args)
{
  on_entry {
    str --> input_string
    format --> format_string
    args --> arg_contents --> arg_refs
  }
  access { input_string, format_string }
  modify { arg_contents, arg_refs }

  analyze Taint {
    arg_contents <- input_string
    arg_refs <- input_string
  }

  analyze FDKind {
    arg_contents <- input_string
    arg_refs <- input_string
  }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

procedure vscanf(format, args)
{
  on_entry {
    format --> format_string
    args --> arg_contents --> arg_refs
  }
  access { format_string, Disk }
  modify { arg_contents, arg_refs }

  analyze FDKind { arg_refs <- StandardIO }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";

  SHOW_NOHANDLE_READ("stdin")
}

procedure vfscanf(stream, format, args)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    format --> format_string
    args --> arg_contents --> arg_refs  }

  access { format_string, Disk }
  modify { arg_contents, arg_refs, IOHandle }

  analyze FDKind { arg_refs <- IOHandle }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";

  SHOW_READ(IOHandle)
}

procedure vsscanf(str, format, args)
{
  on_entry {
    str --> input_string
    format --> format_string
    args --> arg_contents --> arg_refs }

  access { input_string, format_string }
  modify { arg_contents, arg_refs }

  analyze Taint {
    arg_contents <- input_string
    arg_refs <- input_string
  }

  analyze FDKind { arg_refs <- input_string }

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n";
}

// ------------------------------------------------------------
//  get
// ------------------------------------------------------------

procedure fgetc(stream)
{
  on_entry { stream --> file_structure --> IOHandle { name --> name_object } }
  access { Disk }
  modify { IOHandle }

  analyze FDKind { return <- IOHandle }

  SHOW_READ(IOHandle)
}

procedure fgets(str, size, stream)
{
  on_entry { str --> string
	     stream --> file_structure --> IOHandle { name --> name_object } }

  access { Disk }
  modify { IOHandle, string }

  analyze Taint { string <- Tainted }

  analyze FDKind { string <- IOHandle }

  on_exit { return --> string }

  SHOW_READ(IOHandle)
}

procedure getc(stream)
{
  on_entry { stream --> file_structure --> IOHandle { name --> name_object } }
  access { Disk }
  modify { IOHandle }

  analyze FDKind { return <- IOHandle }

  SHOW_READ(IOHandle)
}

procedure getchar()
{
  access { Disk }

  analyze Taint { return <- Tainted }

  analyze FDKind { return <- StandardIO }

  SHOW_NOHANDLE_READ("stdin")
}

procedure gets(str)
{
  on_entry { str --> string }
  access { Disk }
  modify { string }

  analyze Taint { string <- Tainted }

  analyze FDKind { return <- StandardIO }

  on_exit { return --> string }

  SHOW_NOHANDLE_READ("stdin")
}

procedure ungetc(c, stream)
{
  on_entry { stream --> file_structure --> IOHandle }
  modify { stream, IOHandle, Disk }
}

// ------------------------------------------------------------
//  put
// ------------------------------------------------------------

procedure fputc(c, stream)
{
  on_entry { stream --> file_structure --> IOHandle { name --> name_object } }
  modify { IOHandle, Disk }

  SHOW_WRITE(c, IOHandle)
}

procedure fputs(str, stream)
{
  on_entry {
    str --> string
    stream --> file_structure --> IOHandle { name --> name_object }
  }
  access { string }
  modify { IOHandle, Disk }  

  SHOW_WRITE(string, IOHandle)
}

procedure putc(c, stream)
{
  on_entry { stream --> file_structure --> IOHandle { name --> name_object } }
  modify { IOHandle, Disk }

  SHOW_WRITE(c, IOHandle)
}

procedure putchar(c)
{
  modify { Disk }  

  SHOW_NOHANDLE_WRITE(c, "stdout")
}

procedure puts(str)
{
  on_entry { str --> string }
  access { string }
  modify { Disk }  

  SHOW_NOHANDLE_WRITE(string, "stdout")
}

// ------------------------------------------------------------
//  read
// ------------------------------------------------------------

procedure fread(buf_ptr, size, num, stream)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    buf_ptr --> buffer
  }
  access { Disk }
  modify { IOHandle, buffer }

  analyze Taint { buffer <- Tainted }

  analyze FDKind { buffer <- IOHandle }

  SHOW_READ(IOHandle)
}

procedure read(fd, buf_ptr, size)
{
  on_entry {
    fd --> IOHandle { name --> name_object }
    buf_ptr --> buffer { name }
  }

  access { Disk }
  modify { IOHandle, buffer }

  on_exit { buffer { name --> name_object } }

  analyze Taint { buffer <- Tainted }

  analyze FDKind { buffer <- IOHandle }

  SHOW_READ(IOHandle)
}

procedure readv(fd, vector, count)
{
  on_entry {
    fd --> IOHandle { name --> name_object }
    vector --> struct_iovec { iov_base --> buffer,
			      iov_len }
  }

  access { Disk }
  modify { IOHandle, buffer }

  analyze Taint { buffer <- Tainted }

  analyze FDKind { buffer <- IOHandle }

  SHOW_READ(IOHandle)
}

// ------------------------------------------------------------
//  write
// ------------------------------------------------------------

procedure fwrite(buf_ptr, size, num, stream)
{
  on_entry {
    stream --> file_structure --> IOHandle { name --> name_object }
    buf_ptr --> buffer
  }
  access { buffer }
  modify { IOHandle, Disk }

  SHOW_WRITE(buffer, IOHandle)
}

procedure write(fd, buf_ptr, size)
{
  on_entry {
    fd --> IOHandle { name --> name_object }
    buf_ptr --> buffer
  }
  access { buffer }
  modify { IOHandle, Disk }

  SHOW_WRITE(buffer, IOHandle)
}

procedure writev(fd, iovec, count)
{
  on_entry {
    fd --> IOHandle { name --> name_object }
    iovec --> struct_iovec { iov_base --> buffer,
			     iov_len }
  }
  access { buffer }
  modify { IOHandle, Disk }

  SHOW_WRITE(buffer, IOHandle)
}

procedure isatty(desc)
{}

// ------------------------------------------------------------
//  strings
// ------------------------------------------------------------

procedure strcat(dest, src)
{
  on_entry {
    dest --> dest_string
    src --> src_string
  }
  access { src_string }
  modify { dest_string }

  analyze Taint     { dest_string <- src_string }
  analyze FDKind    { dest_string <- src_string }

  on_exit { return --> dest_string }
}

procedure strncat(dest, src, size)
{
  on_entry {
    dest --> dest_string
    src --> src_string
  }
  access { src_string }
  modify { dest_string }

  analyze Taint     { dest_string <- src_string }
  analyze FDKind    { dest_string <- src_string }

  on_exit {
    return --> dest_string
  }
}

procedure strcmp(s1, s2)
{
  on_entry {
    s1 --> s1_string
    s2 --> s2_string
  }
  access { s1_string }
  modify { s2_string }
}

procedure strncmp(s1, s2, size)
{
  on_entry {
    s1 --> s1_string
    s2 --> s2_string
  }
  access { s1_string }
  modify { s2_string }
}

procedure strcasecmp(s1, s2)
{
  on_entry {
    s1 --> s1_string
    s2 --> s2_string
  }
  access { s1_string }
  modify { s2_string }
}

procedure strncasecmp(s1, s2, size)
{
  on_entry {
    s1 --> s1_string
    s2 --> s2_string
  }
  access { s1_string }
  modify { s2_string }
}

procedure strcpy(dest, src)
{
  on_entry {
    dest --> dest_string
    src --> src_string
  }
  access { src_string }
  modify { dest_string }

  analyze Taint     { dest_string <- src_string }
  analyze FDKind    { dest_string <- src_string }

  on_exit { return --> dest_string }
}

procedure stpcpy(dest, src)
{
  on_entry {
    dest --> dest_string
    src --> src_string
  }
  access { src_string }
  modify { dest_string }

  analyze Taint     { dest_string <- src_string }
  analyze FDKind    { dest_string <- src_string }

  on_exit { return --> dest_string }
}

procedure strncpy(dest, src, size)
{
  on_entry {
    dest --> dest_string
    src --> src_string
  }
  access { src_string }
  modify { dest_string }

  analyze Taint     { dest_string <- src_string }
  analyze FDKind    { dest_string <- src_string }

  on_exit { return --> dest_string }
}

procedure strlen(s)
{
  on_entry { s --> s_string }
  access { s_string }
}

procedure strdup(src)
{
  on_entry { src --> src_string }

  access { src_string }
  modify { dup_string }

  analyze Taint     { dup_string <- src_string }
  analyze FDKind    { dup_string <- src_string }

  on_exit { return --> new dup_string }
}

procedure strpbrk(str, find_str)
{
  on_entry {
    str --> string
    find_str --> find_string
  }

  access { string, find_string }

  on_exit { return --> string }
}

procedure strstr(str, find_str)
{
  on_entry {
    str --> string
    find_str --> find_string
  }

  access { string, find_string }

  on_exit { return --> string }
}

procedure strtok(str, find_str)
{
  on_entry {
    str --> string
    find_str --> find_string
  }

  access { string, find_string }

  on_exit { return --> string }
}

procedure strchr(str, find_char)
{
  on_entry { str --> string }

  access { string }

  on_exit { return --> string }
}

procedure strrchr(str, find_char)
{
  on_entry { str --> string }

  access { string }

  on_exit { return --> string }
}

procedure tolower(c) {}

procedure toupper(c) {}

// ------------------------------------------------------------
//  Memory operations
// ------------------------------------------------------------

procedure memcmp(ptr1, ptr2, size)
{
  on_entry {
    ptr1 --> buffer_1
    ptr2 --> buffer_2
  }
  access { buffer_1, buffer_2 }
}

procedure memcpy(dest, src, size)
{
  on_entry {
    dest --> dest_buffer
    src --> src_buffer
  }

  access { src_buffer }
  modify { dest_buffer }

  analyze Taint     { dest_buffer <- src_buffer }
  analyze FDKind    { dest_buffer <- src_buffer }

  on_exit { return --> dest_buffer }
}

procedure memccpy(dest, src, c, size)
{
  on_entry {
    dest --> dest_buffer
    src --> src_buffer
  }

  access { src_buffer }
  modify { dest_buffer }

  analyze Taint     { dest_buffer <- src_buffer }
  analyze FDKind    { dest_buffer <- src_buffer }

  on_exit { return --> dest_buffer }
}

procedure memmove(dest, src, size)
{
  on_entry {
    dest --> dest_buffer
    src --> src_buffer
  }

  access { src_buffer }
  modify { dest_buffer }

  analyze Taint     { dest_buffer <- src_buffer }
  analyze FDKind    { dest_buffer <- src_buffer }

  on_exit { return --> dest_buffer }
}

procedure memset(dest, c, size)
{
  on_entry { dest --> dest_buffer }

  modify { dest_buffer }

  analyze Taint {
    if (c is-exactly Tainted) {
      dest_buffer <- Tainted
    }
  }

  analyze Taint { dest_buffer <- c }

  on_exit { return --> dest_buffer }
}

procedure bzero(dest, size)
{
  on_entry { dest --> dest_buffer }

  modify { dest_buffer }
}

procedure bcopy(src, dest, size)
{
  on_entry {
    dest --> dest_buffer
    src --> src_buffer
  }

  access { src_buffer }
  modify { dest_buffer }

  analyze Taint     { dest_buffer <- src_buffer }
  analyze FDKind    { dest_buffer <- src_buffer }
}

// ------------------------------------------------------------
//  Network information
// ------------------------------------------------------------

procedure gethostname(name, size)
{
  on_entry {
    name --> name_string
  }
  modify { name_string }
}

global { struct_hostent_global,
         h_name_string_global,
	 h_alias_array_global,
	 h_alias_entry_global,
	 h_addr_array_global,
	 h_addr_entry_global }

procedure gethostbyname(name)
{
  on_entry {
    name --> name_string
    struct_hostent_global { h_name, h_aliases, h_addrtype, h_length, h_addr_list }
  }

  access { name_string }

  modify { h_name_string_global,
	     h_alias_entry_global,
	     struct_hostent_global.h_addrtype,
	     struct_hostent_global.h_length,
	     h_addr_entry_global }

  on_exit {
    return --> struct_hostent_global { h_name --> h_name_string_global
                                       h_aliases --> h_alias_array_global --> h_alias_entry_global
				       h_addrtype
                                       h_length
                                       h_addr_list --> h_addr_array_global --> h_addr_entry_global }
  }
}

// These are declared in netdb.h

procedure setnetgrent(item)
{
  on_entry {
    item --> item_string
  }

  access { item_string }
}

procedure getnetgrent(machine_p, user_p, domain_p)
{
  on_entry {
    machine_p --> machine
    user_p --> user
    domain_p --> domain
  }

  modify { machine_string, user_string, domain_string }

  on_exit {
    machine --> new machine_string
    user --> new user_string
    domain --> new domain_string
  }
}

procedure endnetgrent() {}

%{
#include <pwd.h>
}%

global { struct_passwd_global,
	   pw_name_string_global,
	   pw_passwd_string_global,
	   pw_gecos_string_global,
	   pw_dir_string_global,
	   pw_shell_string_global }

procedure getpwnam(name)
{
  on_entry {
    name --> name_string
    struct_passwd_global { pw_name, pw_passwd, pw_uid, pw_gid, pw_gecos, pw_dir, pw_shell }
  }

  access { name_string }

  modify { pw_name_string_global,
	     pw_passwd_string_global,
	     struct_passwd_global.pw_uid,
	     struct_passwd_global.pw_gid,
	     pw_gecos_string_global,
	     pw_dir_string_global,
	     pw_shell_string_global }

  on_exit {
    return --> struct_passwd_global { pw_name --> pw_name_string_global
                                    pw_passwd --> pw_passwd_string_global
                                    pw_uid,
                                    pw_gid,
                                    pw_gecos --> pw_gecos_string_global
                                    pw_dir --> pw_dir_string_global
                                    pw_shell --> pw_shell_string_global }
  }
}

// ------------------------------------------------------------
//  System log
// ------------------------------------------------------------

procedure openlog( ident, option, facility)
{
  on_entry {
    ident --> ident_string
  }
  access { ident_string }
  modify { Disk }
}

procedure syslog( priority, format, args)
{
  on_entry {
    format --> format_string
    args --> arg_contents
  }
  access { format_string, arg_contents }
  modify { Disk }

  SHOW_NOHANDLE_WRITE(arg_contents, "(system log)")

  report if (Taint : format_string is-exactly Tainted) "Tainted argument " ++ [ format ] ++
    " at " ++ @context ++ "(Source is " ++ FDKind : format_string ++ ")\n"; // ++ Taint : format_string @trace ++ "\n";
}

procedure closelog( )
{
  modify { Disk }
}

// ------------------------------------------------------------
//  Reg exp
// ------------------------------------------------------------

%{

#include <regex.h>

}%

procedure regcomp(preg, regex, cflags)
{
  on_entry {
    preg --> regex_buffer
    regex --> regex_string
  }

  access { regex_string }
  modify { regex_buffer }
}

procedure regexec(preg,  string, nmatch,pmatch, eflags)
{
  on_entry {
    preg --> regex_buffer
    string --> string_contents
    pmatch --> pmatch_array --> regmatch_struct { rm_so, rm_eo }
  }

  access { regex_buffer, string_contents }
  modify { regmatch_struct.rm_so, regmatch_struct.rm_eo }
}

procedure regerror(errcode, preg, errbuf, errbuf_size)
{
  on_entry {
    preg --> regex_buffer
    errbuf --> errbuf_contents
  }

  access { regex_buffer }
  modify { errbuf_contents }
}

procedure regfree(preg)
{
  on_entry {
    preg --> regex_buffer
  }

  access { regex_buffer }
}

// ------------------------------------------------------------
//  Signals
// ------------------------------------------------------------

procedure signal(signum, function)
{
  modify { Disk }
}

// ------------------------------------------------------------
// Sockets
// ------------------------------------------------------------

procedure socket(domain, type, protocol)
{
  analyze FDKind {
    if (domain == AF_UNIX)
      IOHandle <- Unix

    if ((domain == AF_INET) ||
	(domain == AF_INET6))
      IOHandle <- Inet

    default
      IOHandle <- Socket
  }

  analyze SocketKind {
    if (type == SOCK_STREAM)
      IOHandle <- Stream
    if (type == SOCK_DGRAM)
      IOHandle <- Datagram
    if (type == SOCK_RAW)
      IOHandle <- Raw
    default
      IOHandle <- Unknown
  }

  analyze SocketState {
    IOHandle <- New
  }

  on_exit { return --> new IOHandle }
}

procedure bind(s, addr_ptr, add_len)
{
  on_entry { s --> IOHandle 
             addr_ptr --> addr { // --- INET addresses
                                 sin_family,
			         sin_port,
			         sin_addr { s_addr },
				 // --- UNIX addresses
				 sun_family,
				 sun_path --> path
			       }
	   }

  access { addr.sin_family,
	   addr.sin_port,
	   addr.sin_addr.s_addr,
	   addr.sun_family,
	   path }

  analyze SocketState { IOHandle <- Bound }

  report if ( ! SocketState : IOHandle is-exactly New)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot be bound (state is " ++
      SocketState : s ++ ")\n";

  report if ((addr.sin_family == AF_INET) &&
	     ! FDKind : IOHandle is-exactly Inet)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot be bound to INET address" ++
      " (kind is " ++ FDKind : IOHandle ++ ")\n";

  report if ((addr.sun_family == AF_UNIX) &&
	     ! FDKind : IOHandle is-exactly Unix)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot be bound to UNIX address" ++
      " (kind is " ++ FDKind : IOHandle ++ ")\n";
}  

procedure listen(s, backlog)
{
  on_entry { s --> IOHandle }

  analyze SocketState { IOHandle <- Listening }

  report if ( ! SocketState : IOHandle is-exactly Bound &&
	      ! SocketState : IOHandle is-exactly Listening)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot listen (state is " ++
      SocketState : IOHandle ++ ")\n";
}


procedure accept(s, addr_ptr, addr_len_ptr)
{
  on_entry { s --> listen_IOHandle
             addr_ptr --> addr { // --- INET addresses
                                 sin_family,
			         sin_port,
			         sin_addr { s_addr },
				 // --- UNIX addresses
				 sun_family,
				 sun_path --> path
			       }
	     addr_len_ptr --> add_len
	   }

  modify { addr.sin_family,
	   addr.sin_port,
	   addr.sin_addr.s_addr,
	   addr.sun_family,
	   path }

  on_exit { return --> new IOHandle }

  analyze SocketState { IOHandle <- Connected }

  report if ( ! SocketState : IOHandle is-exactly Listening)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot accept (state is " ++
      SocketState : IOHandle ++ ")\n";
}

procedure connect(s, addr_ptr, add_len)
{
  on_entry { s --> IOHandle
             addr_ptr --> addr { // --- INET addresses
                                 sin_family,
			         sin_port,
			         sin_addr { s_addr },
				 // --- UNIX addresses
				 sun_family,
				 sun_path --> path
			       }
	   }

  access { addr.sin_family,
	   addr.sin_port,
	   addr.sin_addr.s_addr,
	   addr.sun_family,
	   path }

  on_exit { return --> new IOHandle }

  analyze SocketState { IOHandle <- Connected }

  report if ( ! SocketState : IOHandle is-exactly New)
    "Error at " ++ @context ++ ": socket " ++ [ s ] ++ " cannot be connected (state is " ++
      SocketState : IOHandle ++ ")\n";
}

procedure socketpair(domain, type, protocol, sv)
{
  on_entry { sv --> s }

  on_exit { s --> new IOHandle }

  analyze FDKind {
    if (domain == AF_UNIX)
      IOHandle <- Unix

    if ((domain == AF_INET) ||
	(domain == AF_INET6))
      IOHandle <- Inet

    default
      IOHandle <- Socket
  }

  analyze SocketKind {
    if (type == SOCK_STREAM)
      IOHandle <- Stream
    if (type == SOCK_DGRAM)
      IOHandle <- Datagram
    if (type == SOCK_RAW)
      IOHandle <- Raw
    default
      IOHandle <- Unknown
  }

  analyze SocketState {
    IOHandle <- Connected
  }
}

procedure pipe(sv)
{
  on_entry { sv --> s }

  on_exit { s --> new IOHandle }

  analyze FDKind {
    IOHandle <- Unix
  }

  analyze SocketKind {
    IOHandle <- Stream
  }

  analyze SocketState {
    IOHandle <- Connected
  }
}

procedure dup(oldfd)
{
  on_entry { oldfd --> IOHandle }
  on_exit { return --> IOHandle }
}

procedure dup2(oldfd, newfd)
{
  on_entry { oldfd --> old_IOHandle
	     newfd --> new_IOHandle }

  analyze SocketState {
    new_IOHandle <- New
  }

  on_exit { newfd --> old_IOHandle
	    return --> old_IOHandle }
  
}

procedure shutdown(s, how)
{
  on_entry { s --> IOHandle }

  modify { IOHandle }

  analyze SocketState {
    IOHandle <- New
  }
}

procedure setsockopt(s, level, optname, optval, optlen)
{
  on_entry { s --> IOHandle
	     optval --> optval_contents }

  access { optval_contents }
  modify { IOHandle }
}

procedure getsockopt(s, level, optname, optval, optlen)
{
  on_entry { s --> IOHandle
	     optval --> optval_contents }

  access { IOHandle }
  modify { optval_contents }
}

procedure getsockname(s, addr_ptr, add_len_ptr)
{
  on_entry { s --> IOHandle 
             addr_ptr --> addr { // --- INET addresses
                                 sin_family,
			         sin_port,
			         sin_addr { s_addr },
				 // --- UNIX addresses
				 sun_family,
				 sun_path --> path
			       }
	     add_len_ptr --> add_len
	   }

  access { IOHandle }

  modify { addr.sin_family,
	   addr.sin_port,
	   addr.sin_addr.s_addr,
	   addr.sun_family,
	   path,
	   add_len
	 }
}

procedure send(s, msg, len, flags)
{
  on_entry {
    s --> IOHandle { name --> name_object }
    msg --> msg_buffer
  }

  access { msg_buffer }
  modify { IOHandle, Disk }

  SHOW_WRITE(msg_buffer, IOHandle)

  report if ( ! SocketState : IOHandle is-exactly Connected)
    "Error at " ++ @context ++ ": Socket " ++ [ s ] ++ " may not be connected.\n";
}

procedure sendto(s, msg, len, flags, to, tolen)
{
  on_entry {
    s --> IOHandle { name --> name_object }
    msg --> msg_buffer
    to --> struct_sockaddr
  }

  access { msg_buffer, struct_sockaddr }
  modify { IOHandle, Disk }

  SHOW_WRITE(msg_buffer, IOHandle)
}

procedure sendmsg(s, msg, flags)
{
  on_entry {
    s --> IOHandle { name --> name_object }
    msg --> struct_msghdr {
      msg_name --> msg_name_contents     /* optional address */
      msg_namelen                        /* size of address */
      msg_iov --> iovec { iov_base --> data, iov_len }       /* scatter/gather array */
      msg_iovlen                         /* # elements in msg_iov */
      msg_control --> msg_control_contents  /* ancillary data, see below */
      msg_controllen                     /* ancillary data buffer len */
      msg_flags                          /* flags on received message */
    }
  }

  access { msg_name_contents, struct_msghdr.msg_namelen,
	     iovec.iov_base, iovec.iov_len,
	     struct_msghdr.msg_iovlen, 
	     msg_control_contents, struct_msghdr.msg_controllen,
	     struct_msghdr.msg_flags,
	     data
	 }

  modify { IOHandle, Disk }

  SHOW_WRITE(data, IOHandle)
}


procedure recv(s, buf, len, flags)
{
  on_entry { s --> IOHandle { name --> name_object }
             buf --> buffer }

  modify { buffer, IOHandle, Disk }

  analyze FDKind { buffer <- IOHandle }

  SHOW_READ(IOHandle)
}

procedure recvfrom(s, buf,  len, flags, from, fromlen)
{
  on_entry { s --> IOHandle { name --> name_object }
             buf --> buffer
             from --> struct_sockaddr }

  access { struct_sockaddr }
  modify { buffer, IOHandle, Disk }

  analyze FDKind { buffer <- IOHandle }

  SHOW_READ(IOHandle)
}

// ------------------------------------------------------------
//  Locking
// ------------------------------------------------------------

%{

#include <sys/file.h>

}%

procedure flock(fd, operation)
{
  on_entry { fd --> IOHandle }
  modify { IOHandle }
}

// ------------------------------------------------------------
//  String conversions
// ------------------------------------------------------------

procedure atoi(string)
{
  on_entry { string --> string_contents }
  access { string_contents }
}

procedure atof(string)
{
  on_entry { string --> string_contents }
  access { string_contents }
}

procedure atol(string)
{
  on_entry { string --> string_contents }
  access { string_contents }
}

procedure strtod(string, end_ptr)
{
  on_entry {
    string --> string_contents
    end_ptr --> end
  }

  access { string_contents }

  on_exit { end --> string_contents }
}

procedure strtol(string, end_ptr, base)
{
  on_entry {
    string --> string_contents
    end_ptr --> end
  }

  access { string_contents }

  on_exit { end --> string_contents }
}

procedure strtoul(string, end_ptr, base)
{
  on_entry {
    string --> string_contents
    end_ptr --> end
  }

  access { string_contents }

  on_exit { end --> string_contents }
}

// ----------------------------------------------------------------------
//  Network
// ----------------------------------------------------------------------

%{

#include <netinet/in.h>

}%

procedure htonl(hostlong)
{}

procedure  htons(hostshort)
{}

procedure  ntohl(netlong)
{}

procedure ntohs(netshort)
{}

// ----------------------------------------------------------------------
//  Algorithms
// ----------------------------------------------------------------------

procedure qsort(base, num, size, compare)
{
  on_entry { base --> base_elements }

  access { base_elements }
}
