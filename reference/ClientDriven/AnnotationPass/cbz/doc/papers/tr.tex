\documentclass[10pt]{article}
\usepackage{times}
\usepackage{epsfig}
\usepackage{draftcopy}
\setlength{\topmargin}{-.7in}
\setlength{\textheight}{9in}
\setlength{\textwidth}{6.5in}
\setlength{\oddsidemargin}{0in}

\newcommand{\node}{\texttt{Node}}
\newcommand{\widehzline}{\makebox[\textwidth]{\hrulefill}}
\newcommand{\hozline}{\rule{\textwidth}{0.3mm}}

\begin{document}

\title{The C-Breeze Compiler Infrastructure}
\author{
Adam Brown \\
Samuel Z. Guyer \\ 
Daniel A. Jim\'enez \\
Calvin Lin \\
  Department of Computer Sciences \\
  The University of Texas \\
  Austin, TX 78712 USA }
\date{\today}

\maketitle

This document describes how to use the C-Breeze compiler infrastructure.
C-Breeze accepts ANSI C as input and produces various forms of output.
C-Breeze is written with C++ and makes healthy use of the Standard Template
Library (STL).  This document assumes a familiarity with C++, STL, compiler
terminology, and the grammatical structure of the C language.


\section{Introduction}
\label{sec:Introduction}

    C-Breeze is a compiler infrastructure, written in C++, which accepts ANSI
C (the ISO9899 standard) as input and which can produce various forms of
output, including C and PowerPC assembly.  C-Breeze comes with a set of
built-in phases that perform basic operations.  For example, there are phases
to parse the input, dismantle the input into a canonical form, and produce a
control flow graph.  C-Breeze is also intended to be extended through the
addition of new phases.  This document explains how to use and extend
C-Breeze.

\input{figOverview}

    The high level C-Breeze structure is defined by a series of built-in
phases that define different forms of internal representation.  As shown in
Figure~\ref{fig:Overview}, the parser accepts C source code and produces an
AST (Abstract Syntax Tree) representation.  This AST is fairly high-level and
bears a strong resemblance to C.  The next phase in the figure, the
dismantler, converts the AST into a canonical format known as MIR
(Medium-level Internal Representation), which while still
machine-independent, is a much simpler form with many fewer types of
constructs.  For example, in MIR all control flow is represented by labels
and goto's, and all statements have at most a single assignment operator.
The {\tt -c-code} phase can be invoked to emit C as output.  Eventually,
another lowering phase will be provided to convert the MIR to a
machine-specific LIR format, producing a 3-address code from which it is
easier to generate assembly code.  For most purposes, users will want to
perform their analyses and transformations at the MIR level for simplicity
reasons.  Except for the parser, the invocation of the phases is under user
control, so the structure shown in Figure~\ref{fig:Overview} can be changed
to suit other needs.

    The remainder of this document is organized according to the various
levels of intermediate representation.  We start by describing aspects of the
system that cross-cut the various levels of representation, namely, how to
invoke C-Breeze and how to use the phase structure.  We then describe two
important IR's: the AST that is produced by the parser, and the MIR that is 
generated by the dismantler and its associated control flow graph
We conclude by describing the C-Breeze class hierarchy.

% , and the lower level LIR representation.  


\section{The Basics of C-Breeze}
\label{sec:Basics}

Like most compilers, C-Breeze is organized as a series of phases.  These can
invoked programmatically from within another phase, or they can be invoked by
specifying a command line flag to C-Breeze.  Phases are executed in the order
specified on the command line.  For example, the following line will invoke
the {\tt cfg} phase to dismantle the AST and create a CFG, and then invoke
the {\tt c-code} phase to emit C code as output.  

\begin{small}
\begin{verbatim}
        cbz -cfg -c-code
\end{verbatim}
\end{small}

\noindent
Here and throughout this document, {\tt cbz} refers to the name of the
executable compiler.  The one phase that is implicitly invoked before all
other phases is the parser.


\subsection{User-Defined Phases}

User-defined phases can be named and invoked from the command line.  To do
this, define a class to be a subclass of {\tt Phase} ane define a {\tt run()}
method that contains the code to run when the phase is invoked.  For example,
the trivial phase below prints {\tt Hello, World!} to the standard output.

\begin{small}
\begin{verbatim}
#include "c_breeze.h"

class Hello: public Phase {
        public:
        void run (void) {
                cout << "Hello, World!\n";
        }
};
\end{verbatim}
\end{small}

To name this phase and register it as a flag that can be invoked from the
command line, declare a global variable of type {\tt Phases} (note the
plural) constructed from the name of the phase (represented as a character
string) and an instance of your subclass of {\tt Phase}.  In our Hello
example, the following line registers a new phase that is invoked with the
{\tt -hello} flag.

\begin{small}
\begin{verbatim} 
Phases hello_phase ("hello", new Hello());
\end{verbatim} 
\end{small}

\noindent
Here, the identifier {\tt hello\_phase} is a dummy variable that is never
referenced; it is the invocation of the constructor that registers the
phase.  To define more than one phase in a file, you should obviously give
them different names.  It's not necessary for the names of the {\tt Phases}
variable, the subclass of {\tt Phase}, or the identifying string to be
related, but it does contribute to the readability of your code.

% if your phase class is called {\tt Foo} and you want it to be invoked as 
% {\tt cbz -foo}, put the following statement in a global scope in one of
% your C++ files.

To create useful phases, you will want to access C-Breeze's various internal
representations.  These are available through the {\tt CBZ} class, which is
described in detail in Section~\ref{sec:ClassHierarchy}.  This class has
several {\tt public} and {\tt static} members which can be accessed
directly.  Of particular interest is {\tt CBZ::Program}.  Each element on
this STL list contains the C-Breeze representation for a translation unit (or
source file).  Most phases will traverse this list, applying some analyses or
transformations to each unit.

For details on compiling C-Breeze, please see the release notes that
accompany the source code.  These notes include details on the required
versions of gcc and bison.


\subsection{Predefined Phases}

This section briefly describes C-Breeze's predefined phases.  These are
listed here by their registered names, i.e., to invoke one, prepend a '-' to
its name on the {\tt cbz} command line:

\subsubsection{ {\tt ast}}

The AST phase prints a human-readable version of the abstract syntax tree to
standard output.  For example, given the following {\tt foo.c}:

\begin{small}
\begin{verbatim}
int main () {
        int     a;

        a = 1;
}
\end{verbatim}
\end{small}

Entering {\tt cbz -ast foo.c} will result in this:

\begin{small}
\begin{verbatim}
   0.unit
   1..proc:
   2...decl: "main" proc
   3....func:
   4.....decl: (abstract) formal
   5......prim: void
   6.....prim: int
   7...block:
   8....decl: "a" block
   9.....prim: int
  10....exprstmt:
  11.....binary: op='='
  12......const: val="1"
  13.......prim: int
  14......id: "a" decl=#8
\end{verbatim}
\end{small}

\subsubsection{{\tt c-code}}

The {\tt c-code} phase produces a C code representation of the program,
leaving the result in file(s) with names related to the input file(s).  For
example, entering {\tt cbz -c-code foo.c bar.c} will parse, then unparse {\tt
foo.c} and {\tt bar.c}, leaving the results in {\tt foo.p.c} and {\tt
bar.p.c}.

% This is the phase you want to run after you have done some transformations
% on the C code, so that your result will be saved in a file.


\subsubsection{{\tt ccobj}}

The {\tt -ccobj} flag will use the CBZ::cc\_cmd (usually gcc) to build an
object (.o) file, which can then be linked to produce an executable.  By
using this flag, C-Breeze can be used as a replacement for cc or gcc in
Makefiles.  Note that like the {\tt c-code} phase, this phase generates
intermediate .p.c files.



\subsubsection{{\tt cfg}}

The {\tt cfg} phase first dismantles the C code into MIR form (see
Section~\ref{sec:MIR}) and then creates a control flow graph using a {\tt
basicblockNode} to represent a basic block.  The graph edges are referenced
by the {\tt succs()} and {\tt preds()} STL lists in each {\tt
basicblockNode}; each {\tt procNode} contains a body whose statement list
({\tt stmts()}) is just a list of {\tt basicblockNode}s that are the nodes in
the CFG.  The C code is also commented to show the pred/succ relationship
among the blocks.  For example, consider the following code:

\begin{small}
\begin{verbatim}
int main(int argc, char ** argv) {
  int a, b, c;

  for (a = 1; a<=10; a++) {
    c = a % 2;
    if (c) {
      b = a * 2;
    } else {
      b = a;
    }
  }
}
\end{verbatim}
\end{small}

\noindent 
After processing with the {\tt -cfg} flag, the above code is translated to
the following:

\begin{small}
\begin{verbatim}
int main(int argc, char * * argv)
{
  int a;
  int b;
  int c;
  int __T7;
  int __T10;
  
  {
    /* # 1: preds( ) succs( 2 ) */
    a = 1;
    goto __T1;
  }
  {
    /* # 2: preds( 1 6 ) succs( 3 7 ) */
    __T1:
      ;
    if (a <= 10) goto __T3;
    goto __T2;
  }
  {
    /* # 3: preds( 2 ) succs( 4 5 ) */
    __T3:
      ;
    c = a % 2;
    if (c == 0) goto __T5;
    goto __T12;
  }
  {
    /* # 4: preds( 3 ) succs( 6 ) */
    __T12:
      ;
    b = a * 2;
    goto __T4;
  }
  {
    /* # 5: preds( 3 ) succs( 6 ) */
    __T5:
      ;
    b = a;
    goto __T4;
  }
  {
    /* # 6: preds( 4 5 ) succs( 2 ) */
    __T4:
      ;
    __T10 = a;
    a = a + 1;
    goto __T1;
  }
  {
    /* # 7: preds( 2 ) succs( ) */
    __T2:
      ;
    return __T7;
  }
}
\end{verbatim}
\end{small}

Once the control flow graph has been generated, each function is guaranteed
to have exactly one exit, and that exit is the last block in the list of
statements.  See {\tt cfg.h} for information about invoking the control flow
graph generator programmatically from C++ code.


\subsubsection{{\tt dismantle}}

The {\tt dismantle} phase produces the MIR intermediate format, which
is described in Section~\ref{sec:MIR}.  

% Unlike the {\tt cfg} phase, this phase does not produce a CFG.


\subsubsection{{\tt listphases}}

The {\tt listphases} phase prints a list of C-Breeze's pre-defined phases.


\subsubsection{{\tt vcgAST}}

The {\tt vcgAST} phase provides a way to graphically display the AST.  This
phase generates a specification of the AST that can be read by {\tt xvcg}, a
visualization tool that draws colored graphs.  {\tt xvcg} can display graphs
on the screen and can save the graph in various formats, including
PostScript.  To visualize the AST for a program, {\tt foo.c}, the
{\tt vcgAST} phase will produce the file {\tt foo.c.vcgast}, which can
then be visualized by {\tt xvcg} as follows:

\begin{small}
\begin{verbatim}
    % xvcg foo.c.vcgast
\end{verbatim}
\end{small}

\noindent
If multiple input file names are given to C-Breeze, the output filename
will be called {\tt combined.vcgast}.

The output of this phase uses xvcg version 1.3 revision 3.17 running on
Linux, but FreeBSD and MS Windows versions are also available.  The tool has
a number of useful features, including edge crossing reduction, subgraph
folding, parameterized layouts, and rank assignment, many of which our phase
does not exploit.

\paragraph{Pruning the Graph.}
When the source program is large, it is often desirable to exclude some 
nodes from the graph.  For example, we might want to omit the standard C
header files when displaying the AST.  To exclude source files from the
output graph, create a file, say {\tt exclude.ast}, that has
a list of the source files to be omitted.  This exclusion file might look
something like the following:

\begin{small}
\begin{verbatim}
    /usr/include/bits/types.h
    /usr/include/libio.h
    /usr/include/math.h
    /usr/include/stdio.h
\end{verbatim}
\end{small}

\noindent
Note that the format of the exclusion file requires that each excluded
file reside on a separate line.  Once this exclusion file is created, the
the {\tt exclude flag} can be passed to the visualization phase by invoking
C-Breeze as follows:

\begin{small}
\begin{verbatim}
    % cbz ... -vcgAST exclude:exclude.ast
\end{verbatim}
\end{small}


\subsubsection{{\tt vcgCCG}}

The {\tt vcgCCG} phase is used to visualize the call graph of the input
source programs.  This phase works in the same manner as the {\tt vcgAST}
phase, except that it produces an output file with the {\tt .callg}
extension.  As with the {\tt vcgAST} phase, exclusion files can be used to
limit the scope of this phase.


\section{The AST Level}

As its name implies, the AST representation is a tree.  As mentioned in
Section~\ref{sec:Introduction}, most analyses and transformations will {\em
not} be applied to the AST level.  Nevertheless, to support the direct
manipulation of the AST, C-Breeze defines two classes, walkers and changers,
that simplify the traversal of the AST.

\subsection{Walkers}

A {\em walker} is a subclass of {\tt Walker} that traverses the AST.  Walkers
provide control over the order in which nodes are visited (postorder,
preorder or both) and the depth (top level nodes only, or visit all subtrees)
of the traversal.

The {\tt Walker} class uses the virtual dispatch of C++ to simplify this
traversal: instead of defining the behavior for every possible node type, a
walker need only specify actions for the node types of interest; all other
nodes have a default action (i.e., nothing) performed on them.  New actions 
can specified by by overriding the {\tt at\_}-functions of {\tt Walker}.
There is one {\tt at\_}-function for each C-Breeze node type, e.g., {\tt
at\_for}, {\tt at\_decl}, etc.

\subsubsection{{\tt Walker} subclass definitions}

A walker should be defined in a {\tt .cc} file that {\tt \#include}s {\tt
"c\_breeze.h"} (which will itself {\tt \#include "walker.h"}).  You must
define a constructor for the walker that specifies the order ({\tt
Postorder}, {\tt Preorder} or {\tt Both}) and the depth ({\tt NodeOnly} or
{\tt Subtree}) of the traversal.  You also provide member functions that
override the default actions for the nodes you're interested in.  These {\tt
void} functions accept two parameters:  a pointer to the appropriate subclass
of {\tt Node}, and a parameter of type {\tt Order} that will tell you whether
the node is being visited in preorder (i.e., the parameter {\tt == Preorder})
or postorder (i.e., {\tt == Postorder}).  You can ignore (but must still
declare) this parameter if your {\tt Walker} subclass only goes in one
order.

\subsubsection{A Sample Walker: {\tt recursionWalker}}

Below is a sample walker that will make this idea clear.  When invoked
on every {\tt unitNode}, the {\tt Walker} traverses the AST, listing all the
recursive functions in the program.

\begin{small}
\begin{verbatim}
class recursionWalker: public Walker {
        private:

        string current_proc_name;       // name of the current proc
        bool is_recursive;              // the current proc is recursive

        public:

        // The constructor calls the constructor for Walker, indicating that
        // we'll be descending subtrees in both preorder and postorder.

        recursionWalker (void): Walker (Both, Subtree) {};

        // What to do at a function definition

        void at_proc (procNode *p, Order ord) {

                // get the declaration for the function

                declNode *d = p->decl();

                // What order are we visiting this node from?

                if (ord == Preorder) {

                        // If we haven't visited the function body yet, simply 
                        // remember the current procedure's name and initialize 
                        // is_recursive to false

                        current_proc_name = d->name();
                        is_recursive = false;
                } else {

                        // After we're done with the function body, print a 
                        // message if this function was determined to call 
                        // itself

                        if (is_recursive)
                                cout << d->name() << " is recursive\n";
                }
        }

        // what to do at a function call (sub)expression

        void at_call (callNode *c, Order ord) {

                // If the 'name' (really the expression by which the function 
                // is called) is an identifier expression whose name is the 
                // same as that of the current function, the function is 
                // recursive.  If we're not visiting in Preorder, then we're
                // done, so we'll avoid needlessly executing the 'if' body 
                // again.

                if (ord == Preorder && c->name()->typ() == Id) {
                        idNode *i = (idNode *) c->name();
                        if (i->name() == current_proc_name)
                                is_recursive = true;
                }
        }
};
\end{verbatim}
\end{small}

\subsubsection{Invoking a Walker}

Each AST node type has its own class which defines a {\tt walk} member
function that accepts an object of (sub)class {\tt Walker}.  By calling this
member function of some node with an object of your walker class, you can
start traversing the tree from that node.  Often, you'll want to run your
walker on the entire AST; to do this, you can use the following code segment,
where {\tt yourWalker} is the type name for your walker.

\begin{small}
\begin{verbatim}
        yourWalker w;
        for (unit_list_p u=CBZ::Program.begin(); u!= CBZ::Program.end(); u++)
                (*u)->walk (w);
\end{verbatim}
\end{small}

\noindent
This code calls the {\tt walk} method for each {\tt unitNode} in the program 
using your walker.  

% This is the kind of code you would stick into a phase; 


\subsection{Changers}

Changers let you change the AST in C-Breeze.  A {\em changer} is a subclass
of {\tt Changer}, which walks the AST, changing nodes as it goes.  A changer
is similar to a {\tt Walker} subclass.  You define your changer and override
the {\tt at\_}-functions of the nodes you're interested in, but your new
member functions must now return a {\tt Node * }; this is a pointer to the
new value you want that node to assume. 

{\bf Note:} You need to be careful what you return from a changer's {\tt
at\_}-function; it must ``fit'' in the AST where the old node was.  For
instance, if you return some sort of expression node from, say, the {\tt
at\_stmt} member function, something is going to go wrong because somewhere
in the tree there will be an expression node where a statement node belongs.

\subsubsection{{\tt Changer} subclass definitions}

A changer is defined much like a walker.  The constructor for {\tt Changer}, 
which should be called by the constructor for the subclass, takes three 
parameters.  The first two, the order and depth, are the same as the ones 
for {\tt Walker}.  The third is a {\tt bool} that, if true, causes the new 
{\tt Changer} subclass, when traversing the AST, to delete nodes that have 
been replaced with new nodes in the AST by the changer.

\subsubsection{A Sample Changer}

Here is a sample changer that changes all instances of the pre-increment
operator (e.g. {\tt ++a}) to the equivalent assignment:

\begin{small}
\begin{verbatim}
#include "c_breeze.h"

class preincChanger: public Changer {

        // What to do at a unary node

        Node * at_unary (unaryNode *u, Order) {

                // Is this node doing a preinc?

                if (u->op()->id() == Operator::PREINC) {

                        // Make a node for 'expr + 1'


                        binaryNode * add = new binaryNode ('+',
                                (exprNode *) ref_clone_changer::clone(u->expr(), false),
                                new constNode(1));

                        // Make a node for 'expr = expr + 1'

                        binaryNode *assg = new binaryNode ('=', u->expr(), add);

                        // Return the node

                        return assg;
                }

                // If the node wasn't a preinc, just return it

                return u;
        }

        public:

        preincChanger (void) :
                Changer(Postorder, // visit the tree in postorder (preorder 
                                   // would have worked in this case as well)

                        Subtree,   // descend subtrees

                        false) { } // don't delete the old node; in this case, 
                                   // the old node remains in the tree, it's 
                                   // just placed a little deeper.
};

class preincPhase: public Phase {

public:

preincChanger ic;

void run() {

        unit_list_p u;

        for (u=CBZ::Program.begin(); u!= CBZ::Program.end(); u++) {
                (*u)->change(ic);
        }
}

};

// This line allows you to use the option "-preinc" to invoke
// our phase

Phases Phase("preinc", new preincPhase());
\end{verbatim}
\end{small}

\subsubsection{Invoking a Changer}

A changer is invoked almost the same way a walker is, e.g.

\begin{small}
\begin{verbatim}
        yourChanger c;
        for (unit_list_p u=CBZ::Program.begin(); u!= CBZ::Program.end(); u++)
                (*u)->change (c);
\end{verbatim}
\end{small}


\section{The MIR Level}
\label{sec:MIR}

\input{mir}


\section{The C-Breeze Class Hierarchy}
\label{sec:ClassHierarchy}

This section describes the major components of C-Breeze's C++ class
hierarchy, which is rooted in the {\tt Node} class.  Not all fields or member
functions are described; some fields are seldom used or are just used for
internal C-Breeze bookkeeping.  The complete class hierarchy is available in
the on-line documentation, and the header file {\tt ast.h} contains the
declarations for all the node types.  Nodes follow the C++ convention that
all data fields are private, being accessed through member functions with
related names.  Before describing these major classes, we define some
terminology and conventions.

{\bf Note:}  Some fields are not initialized in the initial AST.  You may 
have to set them yourself, or you may have to call another function
to set them for you.  For example, the fields for keeping type information 
for each expression node are set by the semantic checker and the dismantler.

\subsection{Terminology and Conventions}

Often, STL {\tt list}s of different types of nodes will be used in node
declarations.  These list types are {\tt typedef}ed in {\tt cbreeze.h}.  The
naming convention is to append the string {\tt \_list} to the (possibly
abbreviated) name of the data type to form the list type name, and to append
{\tt \_p} to the list type name in another {\tt typedef} for the {\tt
iterator} of that list.  For example, if {\tt stmtNode} is a node type, {\tt
stmt\_list} would be a list of nodes of type {\tt stmtNode}, and {\tt
stmt\_list\_p} would be the {\tt iterator} type for {\tt stmt\_list}.

The various node types are organized in a C++ class hierarchy.  For example,
the {\tt loopNode} class has subclasses that represent {\tt for}, {\tt do}
and {\tt while} loops.  A {\tt loopNode} is a subclass of a {\tt stmtNode},
an even more general node type containing any kind of statement.  {\tt
stmtNode} is a subclass of {\tt Node}, the most general node type.

This class hierarchy allows the C-Breeze programmer to operate on various
levels of specificity.  For instance, if you want to examine all loops, but
don't care what kind of loop it is, you can write code concerning only {\tt
loopNode}'s.

\subsubsection{Members of Nodes}

Many nodes have fields pointing to children nodes.  The fields are named
according to the syntactical nature of the child.  For example, a {\tt
loopNode} contains an {\tt exprNode*} (an expression node pointer) referred
to by the member function {\tt cond()}.  This expression node is the
condition that continues the loop.  {\tt loopNode} also contains a {\tt
blockNode*} referred to by {\tt body()}.  This block (of statements) node
contains the loop's body.

Another example is the {\tt blockNode}, which contains two STL {\tt list}s of
declaration and statement nodes, referred to by {\tt decls()} and {\tt
stmts()}, respectively.  A block is simply whatever declarations and
executable statements occur between curly braces in C. {\tt blockNode} is a
subclass of {\tt stmtNode} (statement node), since a compound statement is a
statement.

C-Breeze follows a simple naming convention to provide two kinds of
access---destructive and nondestructive---to AST child nodes.  In general,
for an AST child field named {\tt x}, there is a nondestructive {\tt x()}
method that returns a pointer to the field, and there is a destructive {\tt
get\_x()} method that returns a pointer to the field and fills in the old
value with {\tt NULL}.  This second type of accessor is useful to ensure that
the AST remains a tree, as it disallows aliasing amongst AST nodes.  Note,
that these {\tt get\_} methods are not consistently available, and their
incorrect use may unintentionally remove portions of the tree.

\subsubsection{The {\tt CBZ} class}

The {\tt CBZ} class defined in {\tt c\_breeze.h} contains many public static
members can be accessed directly.  These include a container for the AST of
the C program, flags and strings for accessing and controlling options (e.g.
warning level), the current state of processing (e.g., what line number we
are on) and so forth.  See {\tt c\_breeze.h} for the definition of {\tt CBZ}.

\subsubsection{Units}

A C program is composed of one or more translation units.  You can specify
more than one {\tt .c} file on the {\tt cbz} command line.  Each of these
files is parsed into its own translation unit, and the entire program is
represented as an STL list of such units (each of type {\tt unitNode* }).
The list of units is available as the public static member {\tt
CBZ::Program}.


\subsection{{\tt Node}}

This abstract class is the base type for all the other nodes.  It has the
following member functions:

\subsubsection*{Constructors:}

\begin{itemize}
\item
\begin{small}
\begin{verbatim}
Node(NodeType typ, const Coord coord, bool parenthesized = false);
\end{verbatim}
\end{small}

This function makes a node of type {\tt typ} (see below) at coordinate {\tt
coord} (see {\tt coord.h}; the coordinate is basically the location in the C
program text of this node) and with the {\tt parenthesized} attribute, by
default {\tt false} (see below).

\item
\begin{small}
\begin{verbatim}
Node(const Node & other);
\end{verbatim}
\end{small}

This function is a copy constructor, constructing a copy from an existing
node.
\end{itemize}

\subsubsection*{Data fields (wrapped in member functions):} 

\begin{itemize}
\item
\begin{small}
{\tt NodeType typ()};
\end{small}

This method returns the type of this node.  {\tt NodeType} is an enumerated
type in {\tt c\_breeze.h} with fields for all the different kinds of nodes.
See {\tt c\_breeze.h} for the field names; they are pretty self-explanatory.
For example, the value {\tt While} indicates a while-loop node.

\item
\begin{small}
\begin{verbatim}
Coord coord();
void coord(const Coord);
\end{verbatim}
\end{small}

These methods return and set the coordinate of this node, i.e., location in
the C program.  See {\tt coord.h} for details about coordinates.

\item
\begin{small}
\begin{verbatim}
bool parenthesized();
void parenthesized(bool);
\end{verbatim}
\end{small}

These methods return and set the ``parenthesized'' attribute of this node,
that is, whether the node represents an expression inside parentheses.  This
helps when unparsing the program; rather than parenthesize aggressively, the
unparser need only insert parentheses that were in the program to begin
with.

\end{itemize}

\subsubsection*{Other Member Functions:} 

\begin{itemize}

\item
\begin{small}
\begin{verbatim}
virtual typeNode * type();
\end{verbatim}
\end{small}

This method returns {\tt NULL} and can be overridden by a subclass to return
the ``type'' of that node.  {\bf Note:} there are two senses in which we
speak of the ``type'' of a node.  One is the C++ sense:  given a pointer to
an object of an abstract class, what is the actual type of the object?  The
other is the parsed C sense: given a node representing an expression, what is
the type of that expression (e.g., pointer, integer, etc.)?  This method
returns the type in the latter sense; the {\tt typ()} field of {\tt Node}
returns the type in the former sense.

\item
\begin{small}
\begin{verbatim}
virtual typeNode * base_type(bool TdefIndir);
\end{verbatim}
\end{small}

This method returns the ``base type'' of a node; how this differs from the
``type'' of the node depends on its parameter flag.  The {\tt TdefIndir}
flag, if true, causes any {\tt typedef} base types to be dereferenced; i.e.,
instead of returning a {\tt tdefNode *}, {\tt base\_type()} will return the
type referred to by the {\tt typedef}.

\item
\begin{small}
\begin{verbatim}
virtual void visit(Visitor *);
\end{verbatim}
\end{small}

This method can be overriden to provide a {\tt Visitor} with something to do
at that node.

\item
\begin{small}
\begin{verbatim}
virtual void walk(Walker &);
\end{verbatim}
\end{small}

This method can be overriden to provide a {\tt Walker} with something to do
at that node.

\item
\begin{small}
\begin{verbatim}
virtual Node * change(Changer & , bool redispatch = false);
\end{verbatim}
\end{small}

This method can be overriden to provide a {\tt Changer} with something to do
at that node.

\item
\begin{small}
\begin{verbatim}
virtual Node * clone() const =0;
\end{verbatim}
\end{small}

This method returns a pointer to a newly allocated copy of the current node.
Each subclass of {\tt Node} simply overrides this method to return the result
of calling the default copy constructor on itself.

\item
\begin{small}
\begin{verbatim}
virtual void output(output_context & ct, Node * par) =0;
\end{verbatim}
\end{small}

Each subclass of {\tt Node} overrides this method to send readable C code
representing itself to the given output context.  This method is useful for
debugging.  To output a node, first create an {\tt output\_context} that is 
initialized with the desired output stream.  For example,

\begin{small}
\begin{verbatim}
    output_context oc(cout); // output to cout
\end{verbatim}
\end{small}

\noindent
Then call the node's output method as follows:

\begin{small}
\begin{verbatim}
    node->output(oc, NULL);
\end{verbatim}
\end{small}

%In certain contexts, the node must know who its parent is, so the parent node
%of that node is also supplied as a parameter.  For instance, when a {\tt
%blockNode}'s {\tt output} method is called, it needs to know whether its
%parent is a {\tt procNode} (e.g., a function definition) so that it can
%follow a wacky indentation style in which the curly brace in this case is
%placed on a separate line from the function declarator.

\end{itemize}

\subsection{{\tt unitNode}}

A {\tt unitNode} corresponds to the parse tree for a single {\tt .c} file
(translation unit, in ISO9899 terms).

\noindent
The {\tt typ()} field is {\tt Unit}.


\subsubsection*{Constructor:}

\begin{itemize}
\item
\begin{small}
\begin{verbatim}
unitNode(string input_file, string output_file, string obj_file,
         const Coord coord = Coord::Unknown);
\end{verbatim}
\end{small}

The first parameter is the name of the input file.  The second is the name of
the output file, i.e., the file into which the {\tt -c-code} phase will
eventually unparse the AST.  The {\tt obj\_file} parameter specifies the
name of the object file, which is used by the {\tt -ccobj} flag.  The {\tt
coord} is the text coordinate of the unit, providing a context when an {\tt
\#include}d file generates an error message.  You will not normally need to
call the {\tt unitNode} constructor because C-Breeze handles creating,
parsing into and unparsing from them.

\end{itemize}

\subsubsection*{Data fields (wrapped in member functions):}

\begin{itemize}

\item

\begin{small}
\begin{verbatim}
def_list & defs();
const def_list & defs();
\end{verbatim}
\end{small}

These functions get and set the definition list for the {\tt unitNode}.  This
is the list of global function and variable declarations and definitions.
 
\item
\begin{small}
\begin{verbatim}
suespec_list & suespecs(); 
\end{verbatim}
\end{small}

Each unit has its own list of {\tt suespecNode}s.  These are the definitions
to which {\tt sueNode}s refer, i.e., this is where the actual definitions
of {\tt struct}s, {\tt union}s and {\tt enum}s reside, as opposed to having
to duplicate their definitions for each {\tt struct}/{\tt union}/{\tt enum}
declaration and derived type node.

\end{itemize}

\subsection{{\tt defNode}}

A {\tt defNode} is an abstract class intended for {\tt procNode} (procedure
definition) and {\tt declNode} (declaration) to subclass; it's basically
a wrapper for these two types to allow them both to be in a {\tt def\_list}.


\subsection{{\tt declNode}}

A {\tt declNode} contains a declaration for a single object.  What's
an object?  A variable, a {\tt typedef}, and a function prototype are
all examples of things that live in {\tt declNode}s.  {\tt declNode} is
a subclass of {\tt defNode}, so it can live in a {\tt def\_list}, as you
will find in a {\tt unitNode}.

\subsubsection*{Typedefs:}

{\tt declNode} makes some {\tt typedef}s:

\begin{itemize}
\item

\begin{small}
\begin{verbatim}
 typedef enum {                                                                
    UNKNOWN, TOP, BLOCK, FORMAL, SU, ENUM, PROC                                 
 } Decl_location;
\end{verbatim}
\end{small}

This enumerated type names the possible locations of the declaration.  This
information is needed for, among other things, deciding how to format the
declaration for output to a {\tt .c} file.  For example, a declaration in a
function prototype is followed by a comma, but a declaration in the global
scope is followed by a semicolon.

\item

\begin{small}
\begin{verbatim}
 typedef enum {                                                                
    NONE, AUTO, EXTERN, REGISTER, STATIC, TYPEDEF                               
 } Storage_class;                                                              
\end{verbatim}
\end{small}

This enumerated type names the C storage classes.  Note that a {\tt typedef}
is just a variable declaration with storage class {\tt TYPEDEF}.

\end{itemize}

\subsubsection*{Constructors:}

\begin{itemize}

\item

\begin{small}
\begin{verbatim}
declNode(const char * name, Storage_class sc, typeNode * the_type,
         exprNode * init, exprNode * bitsize, const Coord coord = Coord::Unknown);
\end{verbatim}
\end{small}

This method makes a {\tt declNode} with name {\tt name}, storage class {\tt
sc}, type {\tt the\_type}, initializer (possibly {\tt NULL}) {\tt init},
bitfield size (possible {\tt NULL}) {\tt bitsize}, and text coordinate {\tt
coord}.

\item

\begin{small}
\begin{verbatim}
declNode(idNode * id, Storage_class sc, typeNode * the_type, exprNode
         * init, exprNode * bitsize); 
\end{verbatim}
\end{small}

This method is similar to the previous one, but instead of a C character
string, it uses an {\tt idNode} to get the name for the object being
declared.

\item

\begin{small}
\begin{verbatim}
declNode(idNode * name, exprNode * value);
\end{verbatim}
\end{small}

This method is used when building a list of names for an enumerated type; you
probably won't need to call this constructor.

\item

\begin{small}
\begin{verbatim}
declNode(typeNode * the_type, Storage_class sc); 
\end{verbatim}
\end{small}

This method is used to create a declaration from an abstract declarator,
e.g., the parameter in {\tt void foo (int[][40]); }

\end{itemize}

\subsubsection*{Data fields (wrapped in member functions):} 

\begin{itemize}
\item
\begin{small}
\begin{verbatim}
typeNode * type();
void type(typeNode * the_type);
\end{verbatim}
\end{small}

These methods get and set the type of the declaration.

\item

\begin{small}
\begin{verbatim}
string & name();
void name(string name);
\end{verbatim}
\end{small}

These methods get and set the name of the object being declared.

\item
\begin{small}
\begin{verbatim}
exprNode * init();
void init(exprNode * init);
\end{verbatim}
\end{small}

These methods get and set the initializer for this object.  

\item
\begin{small}
\begin{verbatim}
typeNode * no_tdef_type();
\end{verbatim}
\end{small}

This method follows any {\tt typedef}s in the type of the declaration to get
the true type.

\end{itemize}


\appendix

\section{Loop Peeling: An Example Changer}

This appendix shows how to use a {\tt Changer} to perform loop peeling.  This
example shows how to manipulate code at the AST level.

Loop peeling is a transformation that moves the first iteration of a loop 
outside the loop.  Peeling a loop may expose the code to other code-improving
transformations.  See Muchnick, p.374, p.684 for more information.

% We would like to be able to perform loop peeling at the AST level in
% a C program using C-Breeze.  Let's first determine what form the
% transformations should take.  Remember, we want to move the first
% iteration of the loop outside of the loop, but preserve the semantics
% of the code.  We'll use the following transformations:

\subsubsection{{\tt while}}

For a {\tt while} loop, we'll transform the following

\begin{small}
\begin{verbatim}
        while (cond) body;
\end{verbatim}
\end{small}

\noindent
into the following:

\begin{small}
\begin{verbatim}
        if (cond) {
                body;
                while (cond) body;
        }
\end{verbatim}
\end{small}

\noindent
The original meaning is preserved; nothing is executed if the conditional
is false, and the inner {\tt while} loop is still guarded by the same
conditional.

\subsubsection{{\tt do}}

For a {\tt do} loop, we'll convert the following

\begin{small}
\begin{verbatim}
        do {
                body;
        } while (cond);
\end{verbatim}
\end{small}

\noindent
into the following:

\begin{small}
\begin{verbatim}
        body;
        if (cond) {
                do {
                        body;
                } while (cond);
        }
\end{verbatim}
\end{small}

\noindent
Again, the semantics are preserved; the body of a {\tt do} must be executed
at least once; after that, if the conditional, {\tt cond}, is still true, we 
continue with the {\tt do} loop.

\subsubsection{{\tt for}}

For {\tt for} loops we'll cheat a little.  We'll dismantle the following

\begin{small}
\begin{verbatim}
        for (init; cond; next) body;
\end{verbatim}
\end{small}

\noindent
into the following equivalent:

\begin{small}
\begin{verbatim}
        init;
        while (cond) {
                body;
                next;
        }
\end{verbatim}
\end{small}

\noindent
and then do the same transformation that we did for the {\tt while} loop.
Our transformation is incorrect if there is a {\tt continue} in the body of 
the {\tt for} loop, since {\tt continue} doesn't mean the same thing for 
{\tt while} as it does for the {\tt for} statement.  

(Note: C9X, the new ANSI C standard, will most likely allow {\tt init} to be
a variable definition with an initializer and scope limited to the {\tt for}
body, just like in C++; in this case, we will also need to enclose the new
code in curly braces to limit the scope of {\tt init}.)

\subsection{A Loop Peeling Changer}

A {\tt Changer} can change every loop in a program, but this might not be
desirable.  We can use heuristics to decide when to peel, but we don't want
to encode these into our {\tt Changer} since we'd like to keep things simple
and let some other optimization pass decide when to peel.  So we'd like to
structure our {\tt Changer} as a module that can be used by another {\tt
Changer}.

The {\tt Changer} can be invoked by passing an instance of it to a unit's
{\tt change} method, or by another optimization pass that subclasses from
it.

\subsubsection{Class Declaration: {\tt looppeel.h}}

Here is our {\tt Changer}'s class declaration:

\begin{small}
\begin{verbatim}
//
// looppeel.h
//

class LoopPeelingChanger: public Changer {

        // This function will peel a While loop

        Node * peel_while_loop (whileNode *);

        // This function will peel a Do loop

        Node * peel_do_loop (doNode *);

        // This function will peel a For loop

        Node * peel_for_loop (forNode *);

        // This method will peel all loops in the program

        virtual Node * at_loop (loopNode *, Order);

        public:

        // The constructor for LoopPeelingChanger will call the constructor 
        // for Changer such that LoopPeelingChanger will visit tree in 
        // Postorder.

        LoopPeelingChanger (void) :
                Changer(Postorder, Subtree, false) { }

        // This function peels one loop, calling one of the private functions 
        // above.  peel_loop() can be used from a subclass of 
        // LoopPeelingChanger to peel just one loop.

        Node * peel_loop (loopNode *);
};
\end{verbatim}
\end{small}

Most of the member functions of a Walker or Changer accept and return a
(subclass of) {\tt Node *}.  The parameter is the old loop, before peeling.
The return value contains the newly constructed result of peeling the loop.

Note that {\tt loopNode} is an abstract class, whose subclasses are {\tt
whileNode}, {\tt doNode} and {\tt forNode}.  This gives rise to the {\tt
at\_loop()} virtual function of the {\tt Changer} (and {\tt Walker}); from
that point, we are guaranteed to be working with a loop, and we can find out
(using the {\tt typ()} of the {\tt loopNode *}) what kind of loop it is, i.e.
{\tt typ()} will be {\tt For}, {\tt While} or {\tt Do}.

\subsection{Class Definition}

Here are the member functions of {\tt LoopPeelingChanger}, in order of
decreasing generality.  The code is explained in the comments.

\subsubsection{{\tt Node * at\_loop (loopNode *, Order);}}

\begin{small}
\begin{verbatim}
#include "c_breeze.h"
#include "ast.h"
#include "ref_clone_changer.h"
#include "looppeel.h"

// Peel each loop we encounter.  This may not be a good criterion for loop 
// peeling, but it demonstrates the code.  Subclass off of LoopPeelingChanger 
// to implement your own loop peeling policy.  (Note: this depends on the 
// LoopPeelingChanger only visiting the parse tree in postorder; preorder 
// would cause it to peel loops that had just been peeled, ad infinitum.)

Node * LoopPeelingChanger::at_loop (loopNode *p, Order) {
        return peel_loop (p);
}
\end{verbatim}
\end{small}

\subsubsection{{\tt Node * peel\_loop (loopNode *);}}

\begin{small}
\begin{verbatim}
// A loop may be either a for, while, or do.

Node * LoopPeelingChanger::peel_loop (loopNode *p) {

        // call the appropriate peeling functions depending on the type of 
        // this node

        switch (p->typ()) {
                case While:
                        return peel_while_loop ((whileNode *) p);
                case Do:
                        return peel_do_loop ((doNode *) p);
                case For:
                        return peel_for_loop ((forNode *) p);
                default:
                        fprintf (stderr, "unknown loop type!\n");
                        exit (0);
        }
}
\end{verbatim}
\end{small}

\subsubsection{{\tt Node * peel\_while\_loop (whileNode *);}}

\begin{small}
\begin{verbatim}
// Loop peeling transformation for while:
//
// while (expr) stmt;
// =>
// if (expr) {
//      stmt;
//      while (expr) stmt;
// }
//
// Returns a node that is the result of transforming the while node into the 
// if/while node described above.

Node * LoopPeelingChanger::peel_while_loop (whileNode *p) {

        // Build a new block to contain the If stmt body:
        //      { }

        blockNode *newblock = new blockNode (NULL, NULL);

        // Put the copy of the body of the While loop into the
        // if stmt body:
        //      { stmt; }

        newblock->stmts().push_back (
                (stmtNode *) ref_clone_changer::clone(p->body(), false));

        // Make a new copy of the While loop.  This is important because the 
        // changer is going to change 'this' While loop with our new peeled 
        // loop.

        whileNode *newwhile = new whileNode (
                (exprNode *) ref_clone_changer::clone(p->cond(), false),
                (stmtNode *) ref_clone_changer::clone(p->body(), false));

        // Put the copy of the While loop after the While loop body in the If 
        // body:
        //      { stmt; while (expr) stmt; }

        newblock->stmts().push_back ((stmtNode*) newwhile);

        // Wrap everything up in an If stmt with a copy of the While condition 
        // and return it:
        //      if (expr) { stmt; while (expr) stmt; }

        ifNode *newif = new ifNode (
                (exprNode *) ref_clone_changer::clone(p->cond(), false), newblock, NULL);
        return newif;
}
\end{verbatim}
\end{small}

\subsubsection{{\tt Node * peel\_do\_loop (doNode *);}}

\begin{small}
\begin{verbatim}
// Loop peeling transformation for Do:
//
// do stmt while (expr);
// =>
// stmt; if (expr) { do stmt while (expr); }
//
// Returns a node that is the result of the above transformation.

Node * LoopPeelingChanger::peel_do_loop (doNode *p) {

        // We'll return a new block containing both the stmt and the If:
        //      { }

        blockNode *newblock = new blockNode (NULL, NULL);

        // Insert a copy of the Do loop body:
        //      { stmt; }

        newblock->stmts().push_back (
                (stmtNode *) ref_clone_changer::clone(p->body(), false));

        // Make a copy of the entire Do loop:
        //      do stmt while (expr);

        doNode *newdo = new doNode (
                (stmtNode *) ref_clone_changer::clone(p->body(), false),
                (exprNode *) ref_clone_changer::clone(p->cond(), false));

        // Prepend an If to execute the Do if the first iteration hasn't 
        // changed the Do condition:
        //      if (expr) do stmt while (expr);

        ifNode *newif = new ifNode (
                (exprNode *) ref_clone_changer::clone(p->cond(), false), newdo, NULL);

        // Now put everything together in the first block:
        //      { stmt; if (expr) do stmt while (expr); }

        newblock->stmts().push_back ((stmtNode *) newif);
        return newblock;
}
\end{verbatim}
\end{small}

\subsubsection{{\tt Node * peel\_for\_loop (forNode *);}}

\begin{small}
\begin{verbatim}
// `For' is a little trickier since it has so many elements.  We'll first 
// transform it to a While stmt, i.e.:
//
// for (init; cond; next) stmt;
// =>
// init;
// while (cond) {
//      stmt;
//      next;
// }
//
// and then apply the loop peeling code for While.

Node * LoopPeelingChanger::peel_for_loop (forNode *p) {

        // Transform the For loop into a While loop.

        // Everything goes in a new block:
        //      { }

        blockNode *newblock = new blockNode (NULL, NULL);

        // First, insert the initialization of the For:
        //      { init; }

        newblock->stmts().push_back (new exprstmtNode (
                (exprNode *) ref_clone_changer::clone(p->init(), false)));

        // Now build the body of a new While loop...

        blockNode *whilebody = new blockNode (NULL, NULL);

        // ...from the body of the For:
        //      { stmt; }

        whilebody->stmts().push_back (
                (stmtNode *) ref_clone_changer::clone(p->body(), false));

        // ...and the next from the For:
        //      { stmt; next; }

        whilebody->stmts().push_back (new exprstmtNode (
                (exprNode *) ref_clone_changer::clone(p->next(), false)));

        // Now we wrap this body up in a While using the For condition:
        //      while (expr) { stmt; next; }

        whileNode *newwhile = new whileNode (
                (exprNode *) ref_clone_changer::clone(p->cond(), false),
                whilebody);

        // Do loop peeling on the while loop, inserting the result after the 
        // init in the block we made before.

        newblock->stmts().push_back (
                (stmtNode *) peel_while_loop (newwhile));
        return newblock;
}
\end{verbatim}
\end{small}

\subsection{Discussion}

There are some details in the code that aren't immediately obvious.

We must have the {\tt Changer} traverse the tree in postorder.  We are
changing loops into blocks of statements that contain loops.  When we return
a block in the place of a loop, a preorder traversal, having not visited the
``next" statement in that block (indeed, it didn't exist before we created
it) would march down to the loop inside the block we just created.  Since our
policy is to unpeel all loops (or let someone subclass off of us and make up
their own policy), this would cause an infinite loop in which we keep peeling
the same loops over and over again.

Note that we often make copies of {\tt Node}s.  This is usually because we
want the AST to remain a tree.  If we use the same loop body (i.e., the same
{\tt Node*}) outside and inside a loop, then we are asking for trouble; later
on, someone may decide to change something in the loop body, and that change
will unintentionally occur outside the loop, too.

The following line

\begin{small}
\begin{verbatim}
        whilebody->stmts().push_back (new exprstmtNode (
                (exprNode *) ref_clone_changer::clone(p->next(), false)));
\end{verbatim}
\end{small}

\noindent
occurs in the code for {\tt for}.  Here, we are making a copy of the ``next''
expression of the {\tt for}, and then turning it into a statement by
constructing an {\tt exprstmtNode} from it.  An {\tt exprstmtNode} is
required because {\tt exprNode} is not a subclass of {\tt stmtNode}.  When
the C-Breeze AST expects a {\tt stmtNode}, the retuned node {\em must} be a
subclass of {\tt stmtNode}.  An expression can be a statement in C, but can
also occur in contexts where a statement isn't allowed (such as a condition
in a {\tt while} loop).  So we keep expressions that are statements in
special {\tt exprstmtNode}s.  Note that if you don't convert the expression
into a statement (it's easy to forget), C-Breeze might not immediately
complain, but you will be introducing a bug into your program that will
eventually catch up to you later on.

% A subtlety of the C-Breeze parse
% tree is that when a statement is expected, it must be a subclass of a {\tt
% stmtNode}.  

\section{Loop Peeling: A MIR Example}

This section provides an example of a loop peeler that operates at the MIR
level.

\begin{small}
\begin{verbatim}
/*
Loop Peeler, for dismantled code
11/30/03 Walter Chang <walter@cs.utexas.edu>

This demonstrates loop peeling at the MIR level, using cfg, dominators,
loopTree, and related goodies.

Expects: Your stuff in CFG form.  Unfortunately, you must pass it an entire
         unit at a time, because that's what Dismantle::dismantle wants, and
         we need to re-dismantle to fix up labels.

Gives:   Dismantled code with loops peeled.
*/

#include <algorithm>
#include "c_breeze.h"
#include "looppeeldis.h"
#include "cfg.h"

LoopPeelingChangerDismantled::LoopPeelingChangerDismantled(void) : 
  Changer (Postorder, Subtree, false) {}

/*
  at_proc(the_proc, ord)
  
  Runs dominators and loopTree on the_proc, then walks the loop
  tree for the_proc
*/
Node * LoopPeelingChangerDismantled::at_proc(procNode *the_proc, Order ord) {

  myProc = the_proc;
  
  /* let Dominators decorate things */
  Dominators d(the_proc, true);
  
  /* figure out the loop tree */
  loopTree l(the_proc);
    
  /* walk that tree */
  loopTreeWalk(l.topLoop());

  return the_proc;
}

/*
  at_unit(the_unit, ord)

  If we've finished everything for the unit (coming up in postorder),
  re-dismantle the unit to fixup label names.
  Changers should be postorder anyway.
*/
Node * LoopPeelingChangerDismantled::at_unit(unitNode *the_unit, Order ord) {
  cfg_changer::generate_cfg(the_unit);
  return the_unit;
}

/*
  change(u)
  Loop-peels the unit u.
*/
void LoopPeelingChangerDismantled::change(unitNode *the_unit) {
  if(!the_unit) return;
  LoopPeelingChangerDismantled lpcd;
  the_unit->change(lpcd);
}

/*
  change()
  Loop-peels everything.
*/
void LoopPeelingChangerDismantled::change() {
    unit_list_p u;
    for (u=CBZ::Program.begin(); u != CBZ::Program.end(); u++) {
      change( *u );  // change each unit
    }
}

/*
  loopTreeWalk(l)
  Walks loop tree in postorder.  Peel every natural (SingleEntry) loop.
*/
void LoopPeelingChangerDismantled::loopTreeWalk(loopTreeNode * l) {
  loop_set children = l->nestedLoops();
  loop_set::iterator child;

  /* walk the nested loops */
  for(child = children.begin(); child != children.end(); child++) {
    loopTreeWalk( (*child) );
  }

  /* peel this loop, if it is single-entry */
  if(l->kind() == loopTreeNode::SingleEntry) {
    peel(l);
  }
  return;
}

/*
  peel(loopTreeNode * l)

  Peels the single-entry loop indicated by l.

  This should leave the original entry blocks to the loop going to the new
  copy, and all backedges in the loop copy going to the loop top pointing to
  the old loop top.  The body of the loop is not otherwise tinkered with.
*/
void LoopPeelingChangerDismantled::peel(loopTreeNode * l) {

  /* make list of all basic blocks in l's blockset */

  /*
    NOTE:
    We implicitly assume that when we iterate over the block list in a loop,
    that the FIRST block is the loop header.  This assumption is empirically
    true as of 11/30/03.  Should this no longer hold, we must find and move
    the header to the front BEFORE ref-cloning the thing.
  */

  stmt_list loopBlocks = bbset2list(all_blocks(l));

  /* put all basic blocks into one blockNode */
  blockNode loopBodyBlock(NULL,
                          &loopBlocks,
                          Coord::Unknown,
                          Coord::Unknown);
  /*
    ref-clone the block with all the basic blocks in the loop.
    ref-clone should not change the order of the basic blocks.
  */
  blockNode * loopBodyCopy = 
    (blockNode *) (ref_clone_changer::clone(&loopBodyBlock, false));

  stmt_list::iterator lp;
  basicblock_list::iterator lpp;
  stmt_list loop_preds;

  /*
    Look for the entries into the loop, ie, predecessors of
    the header that are not themselves part of the loop
  */
  basicblockNode * loop_header = l->header();
  basicblockNode * loop_newheader = 
    (basicblockNode *) loopBodyCopy->stmts().front();
  
  for(lpp = loop_header->preds().begin(); 
      lpp != loop_header->preds().end(); 
      lpp++) {
    /* If this pred is NOT in the loop's blockset */
    if( find(l->blocks().begin(), l->blocks().end(),
             (*lpp) ) 
        == l->blocks().end()) {
      /* add this pred to the list of loop entries */
      loop_preds.push_front( (*lpp) );
    }
  }

  string lnhName = ((labelNode *) loop_newheader->stmts().front())->name();

  /*
    A basic block always ends in a goto.  It is possible for the next-
    to-last to be a conditionGoto (but not a goto).  These are the only
    possible jump statements you will find in a basic block.
  */

  /* For every (external) entry point to this loop... */
  for(lp = loop_preds.begin(); lp != loop_preds.end(); lp++) {

    /* get the last statement in the block*/
    stmt_list::iterator lastStmtIter = 
      ((basicblockNode *) (*lp))->stmts().end(); lastStmtIter--;

    /* If it comes in via the fall-through... */
    if( ((gotoNode *) (*lastStmtIter))->label()->name() == lnhName) {

      /* ...join that block to the NEW header */
      bbjoin( (basicblockNode *) (*lp), loop_newheader);
    }

    /* if there is a next-to-last... */
    if(lastStmtIter != ((basicblockNode *) (*lp))->stmts().begin()) {
      lastStmtIter--;
      /* ... and it is a conditionGoto... */
      if( (*lastStmtIter)->typ() == Condition ) {
        /* ... and it enters the loop... */
        if( ((conditiongotoNode *) (*lastStmtIter))->label()->name() ==
            lnhName) {
          /* ...join that conditionGoto to the NEW header*/
          bbjoincond( (basicblockNode *) (*lp), loop_newheader);
        }
      }
    }
  }

  /*
    Now we go through all the blocks in the loop, and for any block that goes
    to the top of the loop, make sure it goes to the OLD top of the loop, and
    not the top of the cloned body.  Ordinarily there should be just one such
    block.  [I'm not sure about continue...]
  */

  /* The first thing in a basic block is ALWAYS a label */
  labelNode * loopTop = (labelNode *) loop_header->stmts().front();

  /* for all blocks b that head to the loop top */
  for(lp = loopBodyCopy->stmts().begin();
      lp != loopBodyCopy->stmts().end();
      lp++) {
    /* The last statement in a basic block is ALWAYS a goto */
    gotoNode * endingGoto = (gotoNode *) 
      ((basicblockNode *) (*lp))->stmts().back();
      
    /* If we're going to some loop top... */
    if(endingGoto->label()->name() == loopTop->name()) {
      /* ... make sure it goes to the OLD loop top */
      bbjoin( (basicblockNode *) (*lp), loop_header);
    }

    /* Now we fix up any conditional jumps to the top */

    stmt_list::iterator lastStmtIter = 
      ((basicblockNode *) (*lp))->stmts().end(); lastStmtIter--;

    /* if there is a next-to-last... */
    if(lastStmtIter != ((basicblockNode *) (*lp))->stmts().begin()) {
      lastStmtIter--;
      /* ... and it is a conditionGoto... */
      if( (*lastStmtIter)->typ() == Condition ) {
        /* ... and it goes to some loop top... */
        if( ((conditiongotoNode *) (*lastStmtIter))->label()->name() ==
            loopTop->name()) {
          /* ...join that conditionGoto to the OLD loop top */
          bbjoincond( (basicblockNode *) (*lp), loop_header);
        }
      }
    }
  }

  /*
    At this point, all the labels and gotos for the blocks should be pointing
    at the correct places, and all that remains is to put the blocks into the
    procedure proper.
  */

  /* We'll try to add the new blocks immediately before the original */
  stmt_list::iterator orig_start = find(myProc->body()->stmts().begin(),
                                        myProc->body()->stmts().end(),
                                        l->header());
  for(lp = loopBodyCopy->stmts().begin();
      lp != loopBodyCopy->stmts().end();
      lp++) {
    /* Add block to main body */
    myProc->body()->stmts().insert(orig_start, (*lp) );
    
    /* Add to our parent loop's blockset as well
       Note that we'll never peel the root "loop" which has no parent */
    l->parentLoop()->addBlock( (basicblockNode *) (*lp) );
  }  
}

/*
  bbjoin(b1, b2)

  Joins basic blocks b1 and b2, that is, b1's ending goto points to b2's
  starting label.  Use bbjoincond if you want the conditional to be changed.

  Note that bbjoin does NOT make sure that preds and succs are kept sane.
  This shouldn't be a problem in practice because we'll only be joining "on
  the inside" and re-dismantling will fix it anyway.

*/
void LoopPeelingChangerDismantled::bbjoin(basicblockNode * b1, 
                                          basicblockNode * b2) {
  gotoNode * endingGoto = (gotoNode *) b1->stmts().back();
  labelNode * startLabel = (labelNode *) b2->stmts().front();

  /* remove old label's reference */
  endingGoto->label()->references().remove(endingGoto);
  /* hook up to new label */
  endingGoto->label(startLabel);
}

/*
  bbjoincond(b1, b2)

  Joins basic blocks b1 and b2 via b1's conditionGoto.  The conditionGoto in
  b1 will go to b2, and the fall-through remains unchanged.  Use bbjoin if
  you want to join via the fall-through.

  Note that bbjoincond does NOT make sure that preds and succs are kept
  sane.  This shouldn't be a problem in practice because we'll only be
  joining "on the inside" and re-dismantling will fix it anyway.

*/
void LoopPeelingChangerDismantled::bbjoincond(basicblockNode * b1, 
                                              basicblockNode * b2) {
  labelNode * startLabel = (labelNode *) b2->stmts().front();

  /* Find the next-to-last node, if it is there... */
  stmt_list::iterator i = (b1->stmts()).end(); i--;
  if (i != (b1->stmts()).begin()) {
    i--;
    stmtNode * nextToLast = (*i);
    /* if it is a conditionGoto, fix the target to go to b2. */
    if (nextToLast->typ() == Condition) {
      ((conditiongotoNode *) nextToLast)->
        label()->references().remove((conditiongotoNode *) nextToLast);
      ((conditiongotoNode *) nextToLast)->label(startLabel);
    }
  }
}

/*
  bbset2list(bbset)

  Converts a basicblock_set to a basicblock_list
*/
stmt_list LoopPeelingChangerDismantled::bbset2list(basicblock_set &
                                                     bbset) {
  stmt_list bbl;
  basicblock_set::iterator bbsi;
  for(bbsi = bbset.begin(); bbsi != bbset.end(); bbsi++) {
    bbl.push_back( (*bbsi));
  }
  return stmt_list(bbl);
}

/*
  all_blocks(l)

  Returns all the blocks the loop l includes, including nested
  loops.  Changes loopTreeNodes so that blocks include nested loops.
*/

basicblock_set & LoopPeelingChangerDismantled::all_blocks(loopTreeNode * l) {

  loop_set children = l->nestedLoops();
  loop_set::iterator i;
  basicblock_set::iterator j;
  basicblock_set & b = l->blocks();
  basicblock_set tmp;

  for(i = children.begin(); i != children.end(); i++) {
    tmp = all_blocks( (*i) );
    for(j = tmp.begin(); j != tmp.end(); j++) {
      b.insert( (*j) );
    }
  }
  return b;
}
\end{verbatim}
\end{small}

\section{Known Bugs}

C-Breeze has a number of known bugs.  This section describes a few of these,
which remain because their causes are hard to find, or the cause is known but
the solution is sufficiently difficult to implement that it has not yet been
worth the effort.

\begin{enumerate}

% \item 
% {\tt static} as a storage class for a function definition is ignored by the
% parser.  The {\tt static} storage class in this context causes the function
% to explicitly have internal linkage (ISO9899 6.1.2.2) so this bug can cause
% some programs to have multiply defined symbols at link time.  The workaround
% is to prototype the function in question with the {\tt static} keyword; the
% storage class will stick in the context of a declaration.  (Note: the same
% bug affects other storage classes such as {\tt auto} and {\tt extern}, but
% these are superfluous in the context of a function definition.) 

% \item 
% The dismantler sometimes emits variable declarations for pointers to
% anonymous {\tt struct}s or {\tt union}s (e.g., from a {\tt typedef}).
% C-Breeze automatically tags these {\tt struct}s and {\tt union}s.  The types
% of these pointers don't correspond (as far as C's typing rules know) to the
% original declarations, so an ``incompatible pointer assignment'' warning may
% result from trying to compile such dismantled code.  The workaround is to
% ignore these messages.

\item {\em C-Breeze is a work in progress, and as such some of
the members of the various classes may be defunct or uninitialized, but
still included in the header files.  Also, some members are not intended
to be initialized unless the user (you) specifically requests it with a call
to some method; for instance, a lot of type information is this way.  Don't
assume something does what its name implies it does; make sure to test it
first.}

\item C-Breeze is not GCC.  Although not exactly a bug, this can be annoying
when trying to use {\tt glibc} standard header files.  In order to get
certain functionality that many programs needs, C-Breeze can define the macro
{\tt \_\_GNUC\_\_}, that tells the header files that they are being read by
{\tt GCC}.  Sometimes the header files think that this means it's OK to use
{\tt GCC} extensions not handled by C-Breeze, such as inline assembly
language.  C-Breeze can handle certain GCC extensions (as long as they are in
header files, so that they'll be unparsed back to {\#include} directives),
but some others are not handles so easily.  The workaround is to use or not
use the {\tt -gcc} flag on the C-Breeze command line.  The presence or
absence of this flag toggles certain preprocessor directives that try to
accommodate weird GCCisms.  If C-Breeze fails to compile a program, try using
the {\tt -gcc} flag and see if that helps.  In particular, when using the
{\tt stat(2)} system call, the {\tt struct stat} structure contains a field
that is a scalar (a {\tt long long}) when {\tt \_\_GNUC\_\_} is defined, but
an array (of two {\tt int}s) when it isn't defined.  When this field is
treated as a scalar by user code, you get problems.

\item 
Error messages produced by the C-Breeze parser are not always useful in
tracking down invalid C syntax.

% When there is a parse error from C-Breeze, a segmentation fault almost
% inevitably follows.  To avoid this, debug your C code with your favorite
% ANSI/ISO compliant C compiler before submitting it to C-Breeze.

\end{enumerate}

\end{document}


\section{Getting Started}

To get the best idea of what {\tt dismantle} actually does, run it on a
little C program and read the output from the {\tt c-code} phase.  Basically,
the code is simplified as much as possible without becoming
machine-dependent.  The only side-effect a dismantled expression will have is
a single assignment.  All array accesses are changed to pointer accesses.
All control flow statements and expressions are reduced to sequences of {\tt
if} and {\tt goto}.  Note that {\tt \&\&}, {\tt ||} and {\tt ?:} are control
flow operators and will not appear in dismantled code.

\paragraph{Acknowledgments.}o
Thanks to Alison Smith for many helpful suggestions on this document.
