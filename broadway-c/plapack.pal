%{

#include "PLA.h"

}%

// RowDistribution : captures the distribution of the rows of PLAPACK object

property RowDistribution : { Unknown { NonEmpty { Distributed,
						  Local { Duplicated },
						  Vector },
				       Empty }
			   }

property ColDistribution : { Unknown { NonEmpty { Distributed,
						  Local { Duplicated } },
				       Empty }
			   }

property ObjType : { Vector, Mvector, Pvector, Pmvector, Matrix, Mscalar }

property Value : { Zero, Diagonal { Identity }, Triangular { Upper, Lower } }

property SplitSize : { SomeSplit { SplitTopLeft { SplitLeft, SplitTop },
				   SplitBottomRight { SplitRight, SplitBottom } } }

property Copy : { Redistributed { Identical } }
property DataUsed : { Used { Unused } }

global {

  // -- MPI "world" communicator

  mpi_comm_world,

  // -- Record the initialization state

  plaInitialized,

  // -- Store the communicator

  mpiCommunicator,

  // -- Prevent dead code

  I/O SideEffect
}

procedure PLA_testresults(obj)
{
  on_entry {
    obj --> view { length, width,
		   data --> the_data
		   template --> the_template }
  }
  
  modify { SideEffect, view, the_data }

  analyze DataUsed {
    the_data <- Used
  }
}

// ----------------------------------------------------------------------
//  Initialize
// ----------------------------------------------------------------------

procedure MPI_Init(argc_ptr, argv_ptr)
{
  on_exit { mpi_comm_world --> new communicator { size } }
}

procedure MPI_Comm_rank( comm_handle, rank_out )
{
  on_entry { comm_handle --> communicator }
}

procedure PLA_Init( comm_handle )
{
  on_entry { comm_handle --> communicator { size } }

  modify { plaInitialized,
	   mpiCommunicator }

  analyze constants {
    plaInitialized = 1
  }

  on_exit {
    mpiCommunicator --> communicator
  }
}

procedure MPI_Finalize()
{
  modify { SideEffect }

  on_exit { mpi_comm_world --> null }
}

procedure PLA_Finalize()
{
  analyze constants {
    plaInitialized = 0
  }

  modify { SideEffect }
}

// ----------------------------------------------------------------------
//  Object creation
// ----------------------------------------------------------------------


procedure PLA_Temp_create(nb, offset, template_out)
{
  on_entry { template_out --> templ_ptr }

  on_exit { templ_ptr --> new template { blocking,
                                         offset } }

  analyze constants {
    template.blocking = nb
    template.offset = offset
  }
}

procedure PLA_Matrix_create( datatype, length, width, template_ptr,
                             v_align, h_align, matrix_out )
{
  on_entry { matrix_out --> the_matrix
             template_ptr --> the_template }

  access { the_template, the_matrix }

  analyze constants {
    the_view.length = length
    the_view.width = width
  }

  analyze RowDistribution { the_view <- Distributed }

  analyze ColDistribution { the_view <- Distributed }

  analyze ObjType { the_view <- Matrix }

  on_exit { the_matrix --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Matrix_create_conf_to( obj, matrix_out )
{
  on_entry { obj --> old_view { length, width,
				data,
				template --> the_template }
             matrix_out --> the_matrix
	   }

  access { old_view, the_template, the_matrix }

  analyze constants {
    the_view.length = old_view.length
    the_view.width = old_view.width
  }

  analyze RowDistribution { the_view <- old_view }

  analyze ColDistribution { the_view <- old_view }

  analyze ObjType { the_view <- Matrix }

  on_exit { the_matrix --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  report if ( ! ObjType : old_view is-exactly Matrix )
    "Error at " ++ @context ++ ": Cannot create matrix conformal to " ++
    [ obj ] ++ "; it is a " ++ ObjType : old_view ++ ".\n";

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Vector_create( datatype, length, template_ptr,
			     align, vector_out )
{
  on_entry { vector_out --> the_vector
             template_ptr --> the_template }

  access { the_template, the_vector }

  analyze constants {
    the_view.length = length
    the_view.width = 1
  }

  analyze RowDistribution { the_view <- Vector }

  analyze ColDistribution { the_view <- Local }

  analyze ObjType { the_view <- Vector }

  on_exit { the_vector --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Mvector_create( datatype, length, width, template_ptr,
			      align, vector_out )
{
  on_entry { vector_out --> the_vector
             template_ptr --> the_template }

  access { the_template, the_vector }

  analyze constants {
    the_view.length = length
    the_view.width = width
  }

  analyze RowDistribution { the_view <- Vector }

  analyze ColDistribution { the_view <- Local }

  analyze ObjType { the_view <- Mvector }

  on_exit { the_vector --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Mvector_create_conf_to(obj, num_vectors, vector_out)
{
  on_entry { obj --> old_view { length, width,
				data,
				template --> the_template }

	     vector_out --> the_vector
	   }

  access { old_view, the_template, the_vector }

  analyze constants {
    vector_view.length = old_view.length
    vector_view.width = old_view.width
  }

  analyze RowDistribution { vector_view <- Vector }

  analyze ColDistribution { vector_view <- Local }

  analyze ObjType { vector_view <- Mvector }

  on_exit { the_vector --> new vector_view { length, width,
                                             data --> new data
                                             template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Mscalar_create(datatype, owner_row, owner_col,
			     length, width,
			     template_ptr, mscalar_out )
{
  on_entry { mscalar_out --> the_mscalar
             template_ptr --> the_template }

  access { the_template, the_mscalar }

  analyze constants {
    the_view.length = length
    the_view.width = width
  }

  analyze RowDistribution {
    if (owner_row == PLA_ALL_ROWS) {
      the_view <- Duplicated
    }

    default {
      the_view <- Local
    }
  }

  analyze ColDistribution {
    if (owner_col == PLA_ALL_COLS) {
      the_view <- Duplicated
    }

    default {
      the_view <- Local
    }
  }

  analyze ObjType { the_view <- Mscalar }

  on_exit { the_mscalar --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Mscalar_create_conf_to(obj, owner_row, owner_col, mscalar_out )
{
  on_entry { obj --> old_view { length, width,
				data,
			        template --> the_template }
	     mscalar_out --> the_mscalar
	   }

  access { the_template, old_view, the_mscalar }

  analyze constants {
    the_view.length = old_view.length
    the_view.width = old_view.width
  }

  analyze RowDistribution {
    if (owner_row == PLA_ALL_ROWS) {
      the_view <- Duplicated
    }

    default {
      the_view <- old_view
    }
  }

  analyze ColDistribution {
    if (owner_col == PLA_ALL_COLS) {
      the_view <- Duplicated
    }

    default {
      the_view <- old_view
    }
  }

  analyze ObjType { the_view <- Mscalar }

  on_exit { the_mscalar --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}


procedure PLA_Pvector_create(datatype, project_onto, owner,
			     length, template_ptr, align, vector_out )
{
  on_entry { vector_out --> the_vector
             template_ptr --> the_template }

  access { the_template, the_vector }

  analyze constants {
    the_view.length = length
    the_view.width = 1
  }

  analyze RowDistribution {
    if (project_onto == PLA_PROJ_ONTO_ROW) {
      the_view <- Local
    }

    default {
      the_view <- Distributed
    }
  }

  analyze ColDistribution {
    if (project_onto == PLA_PROJ_ONTO_COL) {
      the_view <- Local
    }

    default {
      the_view <- Distributed
    }
  }

  analyze ObjType { the_view <- Pvector }

  on_exit { the_vector --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Pmvector_create(datatype, project_onto, 
			      owner, length, width, template_ptr,
			      align, vector_out )
{
  on_entry { vector_out --> the_vector
             template_ptr --> the_template }

  access { the_template, the_vector }

  analyze constants {
    the_view.length = length
    the_view.width = width
  }

  analyze RowDistribution {
    if (project_onto == PLA_PROJ_ONTO_ROW) {
      the_view <- Local
    }

    default {
      the_view <- Distributed
    }
  }

  analyze ColDistribution {
    if (project_onto == PLA_PROJ_ONTO_COL) {
      the_view <- Local
    }

    default {
      the_view <- Distributed
    }
  }

  analyze ObjType { the_view <- Pmvector }

  on_exit { the_vector --> new the_view { length, width,
                                          data --> new data
                                          template --> the_template }
	  }

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Pmvector_create_conf_to(obj, project_onto, owner, num_vectors, vector_out)
{
  on_entry { obj --> old_view { length, width,
				data,
				template --> the_template }
	     vector_out --> the_vector
	   }

  access { the_template, the_vector }

  analyze constants {
    vector_view.length = old_view.length
    vector_view.width = num_vectors
  }

  analyze RowDistribution {
    if (project_onto == PLA_PROJ_ONTO_ROW) {
      vector_view <- Local
    }

    default {
      vector_view <- old_view
    }
  }

  analyze ColDistribution {
    if (project_onto == PLA_PROJ_ONTO_COL) {
      vector_view <- Local
    }

    default {
      vector_view <- old_view
    }
  }

  analyze ObjType { vector_view <- Pmvector }

  on_exit { the_vector --> new vector_view { length, width,
                                             data --> new data
                                             template --> the_template }
	  }

  // -- Optimization

  when (ColDistribution : old_view is-exactly Local &&
	(project_onto == PLA_PROJ_ONTO_ROW))
    replace-with %{
      PLA_Mscalar_create_conf_to(${obj}, PLA_ALL_ROWS, PLA_ALL_COLS, ${vector_out});
    }%

  when (RowDistribution : old_view is-exactly Local &&
	(project_onto == PLA_PROJ_ONTO_COL))
    replace-with %{
      PLA_Mscalar_create_conf_to(${obj}, PLA_ALL_ROWS, PLA_ALL_COLS, ${vector_out});
    }%

  // -- Get rid of unused objects

  analyze DataUsed {
    data <- Unused
  }

  when (DataUsed : data @before is-exactly Unused)
    replace-with %{ ; }%
}

procedure PLA_Create_constants_conf_to(obj, minus_one_out, zero_out, one_out)
{
  on_entry { obj --> view { length, width,
			    data,
			    template --> the_template }

	     minus_one_out --> minus_one
	     zero_out --> zero
	     one_out --> one
	   }

  access { view, the_template, minus_one, zero, one }

  analyze constants {
    minus_one_view.width = 1
    minus_one_view.length = 1

    zero_view.width = 1
    zero_view.length = 1

    one_view.width = 1
    one_view.length = 1

    minus_one_data = -1.0
    zero_data = 0.0
    one_data = 1.0
  }

  analyze RowDistribution {
    minus_one_view <- Duplicated
    zero_view <- Duplicated
    one_view <- Duplicated
  }

  analyze ColDistribution {
    minus_one_view <- Duplicated
    zero_view <- Duplicated
    one_view <- Duplicated
  }

  analyze Value {
    minus_one_data <- Diagonal
    zero_data <- Zero
    one_data <- Identity
  }

  on_exit {
    minus_one --> new minus_one_view { length, width,
					 data --> new minus_one_data,
					 template --> the_template }

    zero --> new zero_view { length, width,
			       data --> new zero_data,
			       template --> the_template }

    one --> new one_view { length, width,
			     data --> new one_data,
			     template --> the_template }
  }
}       

procedure PLA_Obj_free(obj_ptr)
{
  on_entry {
    obj_ptr --> obj --> view { length, width,
			       data --> the_data
			       template --> the_template }
  }

  modify { SideEffect }

  on_exit {
    obj --> null
  }

  when (obj == 0) replace-with %{ ; }%

  // -- Track data use. This may seem weird here, but we're relying on
  // loops that could create and destroy the same object over and over.

  // analyze DataUsed {
  //  the_data <- the_data
  // }
}


// ----------------------------------------------------------------------
//  View routines
// ----------------------------------------------------------------------

procedure PLA_Obj_objtype_cast(obj, objtype)
{
  on_entry {
    obj --> view { length, width,
		   data --> the_data
		   template --> the_template }
  }

  modify { view }

  analyze ObjType {
    if (objtype == PLA_MSCALAR) {
      view <- Mscalar
    }

    if (objtype == PLA_VECTOR) {
      view <- Vector
    }

    if (objtype == PLA_MVECTOR) {
      view <- Mvector
    }

    if (objtype == PLA_PVECTOR) {
      view <- Pvector
    }

    if (objtype == PLA_PMVECTOR) {
      view <- Pmvector
    }

    if (objtype == PLA_MATRIX) {
      view <- Matrix
    }
  }
}

procedure PLA_Obj_view(view_in, length, width, align_row, align_col, view_out_ptr)
{
  on_entry {
    view_in --> the_view { length, width,
			     data --> the_data,
			     template --> the_template }
    view_out_ptr --> view_out
  }

  modify { new_view.width, new_view.length, view_out }

  analyze constants {
    new_view.length = length
    new_view.width = width
  }

  analyze RowDistribution {
    if (length == PLA_DIM_ALL) {
      new_view <- the_view
    }

    default {
      new_view <- Distributed
    }
  }

  analyze ColDistribution {
    if (width == PLA_DIM_ALL) {
      new_view <- the_view
    }

    default {
      new_view <- Distributed
    }
  }

  analyze ObjType { new_view <- the_view }

  report "PLA_Obj_view at " ++ @callsite ++ "\n" ++
    "    Object " ++ [ view_in ] ++ " is " ++
    RowDistribution : the_view ++ " by " ++
    ColDistribution : the_view  ++ "\n" ++
    "        New view " ++ [ view_out ] ++ " is " ++
    RowDistribution : new_view @after ++ " by " ++
    ColDistribution : new_view @after ++ "\n\n";

  on_exit {
    view_out --> new new_view { length, width,
				  data --> the_data,
				  template --> the_template }
  }
}

procedure PLA_Obj_view_all( view_in, view_out_ptr )
{
  on_entry {
    view_in --> the_view { length, width,
			     data --> the_data,
			     template --> the_template }
    view_out_ptr --> view_out
  }

  access { the_view.width, the_view.length, view_out }
  modify { new_view.width, new_view.length }

  analyze constants {
    new_view.width = the_view.width
    new_view.length = the_view.length
  }

  analyze RowDistribution { new_view <- the_view }

  analyze ColDistribution { new_view <- the_view }

  analyze ObjType { new_view <- the_view }

  analyze Value { new_view <- the_view }

  on_exit {
    view_out --> new new_view { length, width,
				  data --> the_data,
				  template --> the_template }
  }
}

procedure PLA_Obj_view_swap( obj1_ptr, obj2_ptr)
{
  on_entry {
    obj1_ptr --> obj1 --> obj1_view
    obj2_ptr --> obj2 --> obj2_view
  }

  on_exit {
   obj1 --> obj2_view
   obj2 --> obj1_view
 }
}

procedure PLA_Obj_view_shift(view_in, top, left, right, bottom)
{
  on_entry {
    view_in --> the_view { length, width,
			   data --> the_data,
			   template --> the_template }
  }

  access { the_view.width, the_view.length }
  modify { the_view.width, the_view.length }

  analyze constants {
    the_view.length = the_view.length + top + bottom
    the_view.width = the_view.width + left + right
  }

  // analyze RowDistribution { the_view <- Distributed }

  // analyze ColDistribution { the_view <- Distributed }
}


procedure PLA_Obj_horz_split_2(A, length, upper_ptr, lower_ptr)
{
  on_entry {
    A --> viewA { length, width,
                  data --> dataA
                  template --> the_template }
    upper_ptr --> upper
    lower_ptr --> lower
  }

  access { upper, lower }

  analyze constants {
    if (SplitSize : length is-atleast SplitTopLeft) {
      view_upper.length = length
      view_lower.length = viewA.length - length

      view_upper.width = viewA.width
      view_lower.width = viewA.width
    }

    if (SplitSize : length is-atleast SplitBottomRight) {
      view_upper.length = viewA.length - length
      view_lower.length = length

      view_upper.width = viewA.width
      view_lower.width = viewA.width
    }
  }

  analyze RowDistribution {

    if ((viewA is-exactly Distributed) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_upper <- Local
        view_lower <- Distributed
      }

    if ((viewA is-atleast Local) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_upper <- Local
        view_lower <- Empty
      }

    if ((viewA is-exactly Vector) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_upper <- Local
        view_lower <- Vector
      }

    if ((viewA is-exactly Empty) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_upper <- Empty
        view_lower <- Empty
      }

    if ((viewA is-exactly Distributed) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_upper <- Distributed
	view_lower <- Local
      }

    if ((viewA is-atleast Local) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_upper <- Empty
        view_lower <- Local
      }

    if ((viewA is-exactly Vector) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_upper <- Vector
        view_lower <- Local
      }

    if ((viewA is-exactly Empty) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_upper <- Empty
        view_lower <- Empty
      }
  }

  analyze ColDistribution {
    view_upper <- viewA
    view_lower <- viewA
  }

  analyze ObjType {
    view_upper <- viewA
    view_lower <- viewA
  }

  report "PLA_Obj_horz_split_2 at " ++ @callsite ++ "\n" ++
    "    Object " ++ [ A ] ++ " is " ++
      RowDistribution : viewA ++ " by " ++
      ColDistribution : viewA  ++ "\n" ++
      "        Upper object " ++ [ upper ] ++ " is " ++
      RowDistribution : view_upper @after ++ " by " ++
      ColDistribution : view_upper @after ++ "\n" ++
      "        Lower object " ++ [ lower ] ++ " is " ++
      RowDistribution : view_lower @after ++ " by " ++
      ColDistribution : view_lower @after ++ "\n\n";

  on_exit {
    upper --> new view_upper { length, width,
			  data --> dataA
			  template --> the_template }

    lower --> new view_lower { length, width,
                          data --> dataA
                          template --> the_template }
  }

  when (RowDistribution : viewA is-atleast Local &&
	(SplitSize : length is-atleast SplitTopLeft) &&
	(upper_ptr != 0))
    replace-with %{
      PLA_Obj_view_all(${A}, ${upper_ptr});
    }%

  when (RowDistribution : viewA is-atleast Local &&
	(SplitSize : length is-atleast SplitTopLeft) &&
	(upper_ptr == 0) &&
	(lower is-sameas A))
    replace-with %{ ; }%

  when (RowDistribution : viewA is-atleast Local &&
	(SplitSize : length is-atleast SplitTopLeft) &&
	(lower_ptr == 0) &&
	(upper is-sameas A))
    replace-with %{ ; }%

  when (RowDistribution : viewA is-atleast Local &&
	(SplitSize : length is-atleast SplitTopLeft) &&
	(upper_ptr == 0))
    replace-with %{ ; }%

  when (RowDistribution : viewA is-exactly Empty ||
	ColDistribution : viewA is-exactly Empty)
    replace-with %{ ; }%
}


procedure PLA_Obj_vert_split_2(A, width, left_ptr, right_ptr)
{
  on_entry {
    A --> viewA { length, width,
                  data --> dataA
                  template --> the_template }
    left_ptr --> left
    right_ptr --> right
  }

  access { left, right }

  analyze constants {
    if (SplitSize : width is-atleast SplitTopLeft) {
      view_left.width = width
      view_right.width = viewA.width - width

      view_left.length = viewA.length
      view_right.length = viewA.length
    }

    if (SplitSize : width is-atleast SplitBottomRight) {
      view_left.width = viewA.width - width
      view_right.width = width

      view_left.length = viewA.length
      view_right.length = viewA.length
    }
  }

  analyze RowDistribution {
    view_left <- viewA
    view_right <- viewA
  }

  analyze ColDistribution {

    if ((viewA is-exactly Distributed) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_left <- Local
        view_right <- Distributed
      }

    if ((viewA is-atleast Local) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_left <- Local
        view_right <- Empty
      }

    if ((viewA is-exactly Empty) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_left <- Empty
        view_right <- Empty
      }

    if ((viewA is-exactly Distributed) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_left <- Distributed
	view_right <- Local
      }

    if ((viewA is-atleast Local) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_left <- Empty
        view_right <- Local
      }

    if ((viewA is-exactly Empty) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_left <- Empty
        view_right <- Empty
      }
  }

  analyze ObjType {
    view_left <- viewA
    view_right <- viewA
  }

  report "PLA_Obj_vert_split_2 at " ++ @callsite ++ "\n" ++
    "    Object " ++ [ A ] ++ " is " ++
      RowDistribution : viewA ++ " by " ++
      ColDistribution : viewA  ++ "\n" ++
      "        Left object " ++ [ left ] ++ " is " ++
      RowDistribution : view_left @after ++ " by " ++
      ColDistribution : view_left @after ++ "\n" ++
      "        Right object " ++ [ right ] ++ " is " ++
      RowDistribution : view_right @after ++ " by " ++
      ColDistribution : view_right @after ++ "\n\n";

  on_exit {
    left --> new view_left { length, width,
			     data --> dataA
			     template --> the_template }

    right --> new view_right { length, width,
                               data --> dataA
                               template --> the_template }
  }

  when (ColDistribution : viewA is-atleast Local &&
	(SplitSize : width is-atleast SplitTopLeft) &&
	(left_ptr != 0))
    replace-with %{
      PLA_Obj_view_all(${A}, ${left_ptr});
    }%

  when (ColDistribution : viewA is-atleast Local &&
	(SplitSize : width is-atleast SplitTopLeft) &&
	(left_ptr == 0) &&
	(right is-sameas A))
    replace-with %{ ; }%

  when (ColDistribution : viewA is-atleast Local &&
	(SplitSize : width is-atleast SplitTopLeft) &&
	(right_ptr == 0) &&
	(left is-sameas A))
    replace-with %{ ; }%

  when (ColDistribution : viewA is-atleast Local &&
	(SplitSize : width is-atleast SplitTopLeft) &&
	(left_ptr == 0))
    replace-with %{ ; }%

  when (RowDistribution : viewA is-exactly Empty ||
	ColDistribution : viewA is-exactly Empty)
    replace-with %{ ; }%
}


procedure PLA_Obj_split_4( A, length, width,
                           A11_ptr, A12_ptr, A21_ptr, A22_ptr)
{
  on_entry {
    A --> view_A { length, width,
                  data --> dataA
                  template --> the_template }
    A11_ptr --> A11
    A12_ptr --> A12
    A21_ptr --> A21
    A22_ptr --> A22
  }

  access { A11, A12, A21, A22 }

  analyze constants {
    if ((SplitSize : length is-atleast SplitTopLeft) &&
	(SplitSize : width  is-atleast SplitTopLeft)) {
      view_A11.length = length
      view_A11.width = width
    }

    if ((SplitSize : length is-atleast SplitTopLeft) &&
	(SplitSize : width  is-atleast SplitBottomRight)) {
      view_A12.length = length
      view_A12.width = width
    }

    if ((SplitSize : length is-atleast SplitBottomRight) &&
	(SplitSize : width  is-atleast SplitTopLeft)) {
      view_A21.length = length
      view_A21.width = width
    }

    if ((SplitSize : length is-atleast SplitBottomRight) &&
	(SplitSize : width  is-atleast SplitBottomRight)) {
      view_A22.length = length
      view_A22.width = width
    }
  }

  analyze RowDistribution {

    if ((view_A is-exactly Distributed) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_A11 <- Local
        view_A12 <- Local
        view_A21 <- Distributed
        view_A22 <- Distributed }

    if ((view_A is-atleast Local) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_A11 <- Local
        view_A12 <- Local
        view_A21 <- Empty
        view_A22 <- Empty }

    if ((view_A is-exactly Vector) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_A11 <- Local
        view_A12 <- Local
        view_A21 <- Vector
        view_A22 <- Vector }

    if ((view_A is-exactly Empty) &&
	(SplitSize : length is-atleast SplitTopLeft))
      { view_A11 <- Empty
        view_A12 <- Empty
        view_A21 <- Empty
        view_A22 <- Empty }

    if ((view_A is-exactly Distributed) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_A11 <- Distributed
        view_A12 <- Distributed
        view_A21 <- Local
        view_A22 <- Local }

    if ((view_A is-atleast Local) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_A11 <- Empty
        view_A12 <- Empty
        view_A21 <- Local
        view_A22 <- Local }

    if ((view_A is-exactly Vector) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_A11 <- Vector
        view_A12 <- Vector
        view_A21 <- Local
        view_A22 <- Local }

    if ((view_A is-exactly Empty) &&
	(SplitSize : length is-atleast SplitBottomRight))
      { view_A11 <- Empty
        view_A12 <- Empty
        view_A21 <- Empty
        view_A22 <- Empty }
  }

  analyze ColDistribution {

    if ((view_A is-exactly Distributed) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_A11 <- Local
        view_A12 <- Distributed
        view_A21 <- Local
        view_A22 <- Distributed }

    if ((view_A is-atleast Local) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_A11 <- Local
        view_A12 <- Empty
        view_A21 <- Local
        view_A22 <- Empty }

    if ((view_A is-exactly Empty) &&
	(SplitSize : width is-atleast SplitTopLeft))
      { view_A11 <- Empty
        view_A12 <- Empty
        view_A21 <- Empty
        view_A22 <- Empty }

    if ((view_A is-exactly Distributed) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_A11 <- Distributed
        view_A12 <- Local
        view_A21 <- Distributed
        view_A22 <- Local }

    if ((view_A is-atleast Local) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_A11 <- Empty
        view_A12 <- Local
        view_A21 <- Empty
        view_A22 <- Local }

    if ((view_A is-exactly Empty) &&
	(SplitSize : width is-atleast SplitBottomRight))
      { view_A11 <- Empty
        view_A12 <- Empty
        view_A21 <- Empty
        view_A22 <- Empty }
  }

  analyze ObjType {
    view_A11 <- view_A
    view_A12 <- view_A
    view_A21 <- view_A
    view_A22 <- view_A
  }

  report "PLA_Obj_split_4 at " ++ @callsite ++ "\n" ++
    "    Object " ++ [ A ] ++ " is " ++
      RowDistribution : view_A ++ " by " ++
      ColDistribution : view_A  ++ "\n" ++
      "        A11 object " ++ [ A11 ] ++ " is " ++
      RowDistribution : view_A11 @after ++ " by " ++
      ColDistribution : view_A11 @after ++ "\n" ++
      "        A12 object " ++ [ A12 ] ++ " is " ++
      RowDistribution : view_A12 @after ++ " by " ++
      ColDistribution : view_A12 @after ++ "\n" ++
      "        A21 object " ++ [ A21 ] ++ " is " ++
      RowDistribution : view_A21 @after ++ " by " ++
      ColDistribution : view_A21 @after ++ "\n" ++
      "        A22 object " ++ [ A22 ] ++ " is " ++
      RowDistribution : view_A22 @after ++ " by " ++
      ColDistribution : view_A22 @after ++ "\n\n";

  on_exit {
    A11 --> new view_A11 { length, width,
			  data --> dataA
			  template --> the_template }

    A12 --> new view_A12 { length, width,
                          data --> dataA
                          template --> the_template }

    A21 --> new view_A21 { length, width,
                          data --> dataA
                          template --> the_template }

    A22 --> new view_A22 { length, width,
                          data --> dataA
                          template --> the_template }
  }

  // -- Optimizations
}

// ----------------------------------------------------------------------
//  Queries
// ----------------------------------------------------------------------

procedure PLA_Obj_global_length(obj, length_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    length_ptr --> length
  }

  modify { length }

  analyze constants {
    if (RowDistribution : view is-exactly Empty) {
      length = 0
    }
  }

  report if (RowDistribution : view is-exactly Empty)
    "PLA_Obj_global_length of " ++ [ obj ] ++ " is zero.\n";

  /*
  when (RowDistribution : view is-exactly Empty)
    replace-with %{ *(${length_ptr}) = 0; }%
    */
}


procedure PLA_Obj_global_width(obj, width_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    width_ptr --> width
  }

  modify { width }

  analyze constants {
    if (ColDistribution : view is-exactly Empty) {
      width = 0
    }
  }

  report if (ColDistribution : view is-exactly Empty)
    "PLA_Obj_global_width of " ++ [ obj ] ++ " is zero.\n";
}


procedure PLA_Obj_local_length(obj, length_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    length_ptr --> length
  }

  modify { length }

  analyze constants {
    if (RowDistribution : view is-exactly Empty) {
      length = 0
    }
  }
}


procedure PLA_Obj_local_width(obj, width_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    width_ptr --> width
  }

  modify { width }

  analyze constants {
    if (ColDistribution : view is-exactly Empty) {
      width = 0
    }
  }
}


procedure PLA_Obj_set_orientation(obj, project_onto)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
  }
}


procedure PLA_Obj_split_size(obj, side, size_ptr, owner_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    size_ptr --> size
    owner_ptr --> owner
  } 

  access { view.length, view.width, the_template }
  modify { size, owner }

  analyze constants {
    if ((RowDistribution : view is-exactly Empty) &&
	((side == PLA_SIDE_TOP) ||
	 (side == PLA_SIDE_BOTTOM)))
      {
	size = 0
      }

    if ((ColDistribution : view is-exactly Empty) &&
	((side == PLA_SIDE_LEFT) ||
	 (side == PLA_SIDE_RIGHT)))
      {
	size = 0
      }
  }

  analyze SplitSize {

    if (side == PLA_SIDE_TOP) {
      size <- SplitTop
    }

    if (side == PLA_SIDE_LEFT) {
      size <- SplitLeft
    }

    if (side == PLA_SIDE_BOTTOM) {
      size <- SplitBottom
    }

    if (side == PLA_SIDE_RIGHT) {
      size <- SplitRight
    }
  }

  report "PLA_Obj_split_size at " ++ @callsite ++ "\n" ++
    "    Object " ++ [ obj ] ++ " is " ++ RowDistribution : view ++
      " " ++ ColDistribution : view  ++ "\n";
}


procedure PLA_Obj_template(obj, template_ptr_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    template_ptr_ptr --> template_ptr
  } 

  on_exit {
    template_ptr --> the_template
  }
}

procedure PLA_Environ_nb_alg(operation, template_ptr, nb_ptr)
{
  on_entry {
    template_ptr --> template
    nb_ptr --> nb
  }

  access { template }

  analyze SplitSize {
    nb <- SplitTopLeft
  }
}

procedure PLA_Temp_comm_row_rank(template_ptr, rank_ptr)
{
  on_entry {
    template_ptr --> the_template
    rank_ptr --> rank
  }

  access { the_template }
  modify { rank }
}

procedure PLA_Temp_comm_col_rank(template_ptr, rank_ptr)
{
  on_entry {
    template_ptr --> the_template
    rank_ptr --> rank
  }

  access { the_template }
  modify { rank }
}

procedure PLA_Temp_comm_row_size(template_ptr, size_ptr)
{
  on_entry {
    template_ptr --> the_template
    size_ptr --> size
  }

  access { the_template }
  modify { size }
}

procedure PLA_Temp_comm_col_size(template_ptr, size_ptr)
{
  on_entry {
    template_ptr --> the_template
    size_ptr --> size
  }

  access { the_template }
  modify { size }
}


procedure PLA_Temp_nb(template_ptr, nb_ptr)
{
  on_entry {
    template_ptr --> the_template
    nb_ptr --> nb
  }

  access { the_template }
  modify { nb }
}

procedure PLA_Obj_datatype(obj, datatype_out)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }

    datatype_out --> datatype
  }

  modify { datatype }
}

// ----------------------------------------------------------------------
//  Copy
// ----------------------------------------------------------------------

procedure PLA_Copy( source, target )
{
  on_entry {
    source --> source_view { length, width,
			     data --> source_data,
			     template --> the_template
			     copy_of --> source_copied --> copied_view 
			   }

    target --> target_view { length, width,
			     data --> target_data,
			     template --> the_template
			     copy_of
			   }
  } 

  access { source_data, source_view.length, source_view.width,
	     // target_view.length, target_view.width,
	   the_template
	 }

  modify { target_data }

  // -- Opt: Remove copies on empty views

  when (RowDistribution : source_view is-exactly Empty ||
	ColDistribution : source_view is-exactly Empty ||
	RowDistribution : target_view is-exactly Empty ||
	ColDistribution : target_view is-exactly Empty)
    replace-with %{ ; }%

  // -- Hacked version of copy propagation

  on_exit { target_view.copy_of --> source }

  analyze Copy {
    if (RowDistribution : source_view is-exactly target_view &&
	ColDistribution : source_view is-exactly target_view) {
      target_view <- Identical
    }

    default {
      target_view <- Redistributed
    }
  }

  when ((source == 0) ||
	(target == 0))
    replace-with %{ ; }%

  // -- Remove Unecessary copy: as a result of the above optimization, we
  // could have PLA_Copy(A, A), which we'll just get rid of.

  when (source_view is-sameas target_view)
    replace-with %{ ; }%

  // -- Copy propagate the source object: basically, if the source is a
  // copy of something else, then put that something else in as the first
  // argument.

  when ((copied_view is-sameas target_view) &&
	Copy : source_view is-exactly Identical)
    replace-with %{ PLA_Copy(${source_copied}, ${target}); }%

  // -- Try to get rid of unused data copies

  analyze DataUsed {
    source_data <- Used
    target_data <- Unused
  }

//  when (DataUsed : target_data @before is-exactly Unused)
//    replace-with %{ ; }%

  /* Probably not safe:
  when (RowDistribution : source_view is-exactly target_view &&
	ColDistribution : source_view is-exactly target_view)
    replace-with %{
      PLA_Local_copy(${source}, ${target});
    }%
    */

  when (RowDistribution : source_view is-atleast Local &&
	ColDistribution : source_view is-atleast Local &&
	! ObjType : source_view is-exactly Mscalar)
    replace-with %{
      {
	PLA_Obj_objtype_cast(${source}, PLA_MSCALAR);
	PLA_Copy(${source}, ${target});
      }
    }%
}

procedure PLA_Local_copy( source, target )
{
  on_entry {
    source --> source_view { length, width,
			       data --> source_data,
			       template --> the_template }

    target --> target_view { length, width,
			       data --> target_data,
			       template --> the_template }
  } 

  access { source_data, source_view.length, source_view.width,
	   target_view.length, target_view.width,
	   the_template
	 }

  modify { target_data }

  analyze DataUsed {
    source_data <- Used
    target_data <- Unused
  }

  when (DataUsed : target_data @before is-exactly Unused)
    replace-with %{ ; }%
}

// ----------------------------------------------------------------------
//  Contents
// ----------------------------------------------------------------------

procedure PLA_Obj_set_to_zero(obj)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
  }

  modify { data }

  analyze constants {
    data = 0.0
  }
}

procedure PLA_Obj_set_to_one(obj)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
  }

  modify { data }

  analyze constants {
    data = 1.0
  }
}

procedure PLA_Obj_set_to_minus_one(obj)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
  }

  modify { data }

  analyze constants {
    data = -1.0
  }
}

procedure PLA_Obj_set(obj, datatype, value_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    value_ptr --> value
  }

  access { value }
  modify { data }

  analyze constants {
    data = value
  }
}

procedure PLA_Obj_local_buffer(obj, buffer_ptr_ptr)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    buffer_ptr_ptr --> buffer_ptr
  }

  on_exit {
    buffer_ptr --> data
  }
}

procedure PLA_Obj_get_local_contents(obj, trans, rows_ptr, cols_ptr,
				     buf_ptr, ldim_buf, stride_buf)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    rows_ptr --> rows
    cols_ptr --> cols
    buf_ptr --> buffer
  }

  access { view.length, view.width }
  modify { rows, cols }

  analyze constants {
    buffer = data
  }
}

procedure PLA_Obj_set_local_contents(trans, rows, cols,
				     buf_ptr, ldim_buf, stride_buf, obj)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
    buf_ptr --> buffer
  }

  analyze constants {
    data = buffer
  }
}

// ----------------------------------------------------------------------
//  Computations
// ----------------------------------------------------------------------

procedure PLA_Local_chol(uplo, obj)
{
  on_entry {
    obj --> view { length, width,
                   data --> data
                   template --> the_template }
  } 

  access { view.length, view.width, data }
  modify { data }

  report "At PLA_Local_chol: " ++ [ obj ] ++ " is " ++ 
    RowDistribution : view ++ " " ++ ColDistribution : view  ++ "\n";

  report if ( ! (RowDistribution : view is-exactly Local &&
		 ColDistribution : view is-exactly Local))
    "ERROR at " ++ @callsite ++ ": input object " ++ [ obj ] ++ " must be local.\n";

  analyze DataUsed {
    data <- Used
  }
}

// ----------------------------------------------------------------------
//  Level 1: Vector Operations
// ----------------------------------------------------------------------

procedure PLA_Scal(alpha, a)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // -- Make sure alpha and beta are multi-scalars

    report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty)
    replace-with %{ ; }%

  when (data_alpha == 1)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
  }
}

procedure PLA_Local_scal(alpha, a)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty)
    replace-with %{ ; }%

  when ((data_alpha == 1.0) ||
	Value : data_alpha is-exactly Identity)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
  }
}


// ----------------------------------------------------------------------
//  Level 2: Matrix-Vector Operations
// ----------------------------------------------------------------------

procedure PLA_gemv(transa, transb, a, b, beta, c)
{
  on_entry {

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_beta  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": beta argument " ++ [ beta ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty )
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Local_gemv(transa, transb, a, b, beta, c)
{
  on_entry {
    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_beta  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": beta argument " ++ [ beta ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty )
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Symv(uplo, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty )
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Local_symv(uplo, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Trmv(uplo, transa, diag, a, b)
{
  on_entry {

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_a <- Used
    data_b <- Used
  }
}

procedure PLA_Local_trmv(uplo, transa, diag, a, b)
{
  on_entry {

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_a <- Used
    data_b <- Used
  }
}

procedure PLA_Trsv(uplo, transa, diag, a, b)
{
  on_entry {
    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%
}

procedure PLA_Local_trsv(uplo, transa, diag, a, b)
{
  on_entry {
    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }
  }

  access { view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_a <- Used
    data_b <- Used
  }
}

procedure PLA_Ger(alpha, x, y, a)
{
  on_entry {

    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    y --> view_y { length, width,
		   data --> data_y
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_y.length, view_y.width, data_y,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty ||
	RowDistribution : view_y is-exactly Empty ||
	ColDistribution : view_y is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
    data_y <- Used
  }
}

procedure PLA_Local_ger(alpha, x, y, a)
{
  on_entry {
    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    y --> view_y { length, width,
		   data --> data_y
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_y.length, view_y.width, data_y,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_x is-atleast Local ||
		 RowDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_x ++ "\n";

  report if ( ! (RowDistribution : view_y is-atleast Local ||
		 RowDistribution : view_y is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ y ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_y ++ "\n";

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_x is-atleast Local ||
		 ColDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_x ++ "\n";

  report if ( ! (ColDistribution : view_y is-atleast Local ||
		 ColDistribution : view_y is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ y ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_y ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";


  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty ||
	RowDistribution : view_y is-exactly Empty ||
	ColDistribution : view_y is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
    data_y <- Used
  }
}

procedure PLA_Syr(uplo, alpha, x, a)
{
  on_entry {

    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
  }
}

procedure PLA_Local_syr(uplo, alpha, x, a)
{
  on_entry {
    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_x is-atleast Local ||
		 RowDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_x ++ "\n";

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_x is-atleast Local ||
		 ColDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_x ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";


  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
  }
}

procedure PLA_Syr2(uplo, alpha, x, y, a)
{
  on_entry {

    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    y --> view_y { length, width,
		   data --> data_y
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_y.length, view_y.width, data_y,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty ||
	RowDistribution : view_y is-exactly Empty ||
	ColDistribution : view_y is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
    data_y <- Used
  }
}

procedure PLA_Local_syr2(uplo, alpha, x, y, a)
{
  on_entry {
    alpha --> view_alpha { length, width,
		           data --> data_alpha
                           template --> the_template }

    x --> view_x { length, width,
		   data --> data_x
                   template --> the_template }

    y --> view_y { length, width,
		   data --> data_y
                   template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }
  }

  access { view_x.length, view_x.width, data_x,
	   view_y.length, view_y.width, data_y,
	   view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a }

  modify { data_a }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_x is-atleast Local ||
		 RowDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_x ++ "\n";

  report if ( ! (RowDistribution : view_y is-atleast Local ||
		 RowDistribution : view_y is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ y ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_y ++ "\n";

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_x is-atleast Local ||
		 ColDistribution : view_x is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ x ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_x ++ "\n";

  report if ( ! (ColDistribution : view_y is-atleast Local ||
		 ColDistribution : view_y is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ y ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_y ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";


  // -- Make sure alpha and alpha are multi-scalars

  report if ( ! ObjType : view_alpha  is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_x is-exactly Empty ||
	ColDistribution : view_x is-exactly Empty ||
	RowDistribution : view_y is-exactly Empty ||
	ColDistribution : view_y is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_x <- Used
    data_y <- Used
  }
}



// ----------------------------------------------------------------------
//  Level 3: Matrix-Matrix Operations
// ----------------------------------------------------------------------

procedure PLA_Gemm(transa, transb, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Local_gemm(transa, transb, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Symm(side, uplo, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Local_symm(side, uplo, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%


  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Syrk(side, uplo, alpha, a, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_c <- Used
  }
}

procedure PLA_Local_syrk(side, uplo, alpha, a, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_c <- Used
  }
}

procedure PLA_Syr2k(uplo, trans, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Local_syr2k(uplo, trans, alpha, a, b, beta, c)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }

    beta --> view_beta { length, width,
		         data --> data_beta
                         template --> the_template }

    c --> view_c { length, width,
		   data --> data_c
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b,
	   view_beta.length, view_beta.width, data_beta,
	   view_c.length, view_c.width, data_c }

  modify { data_c }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (RowDistribution : view_c is-atleast Local ||
		 RowDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_c ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_c is-atleast Local ||
		 ColDistribution : view_c is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ c ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_c ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! (ObjType : view_alpha is-exactly Mscalar &&
		 ObjType : view_beta  is-exactly Mscalar))
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " and beta argument " ++ [ beta ] ++ " must be 1x1 multi-scalars.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty ||
	RowDistribution : view_c is-exactly Empty ||
	ColDistribution : view_c is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_beta <- Used
    data_a <- Used
    data_b <- Used
    data_c <- Used
  }
}

procedure PLA_Trmm(side, uplo, transa, diag, alpha, a, b)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // -- Make sure alpha and beta are multi-scalars

    report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_b <- Used
  }
}

procedure PLA_Local_trmm(side, uplo, transa, diag, alpha, a, b)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template
		 }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_b <- Used
  }
}


procedure PLA_Trsm(side, uplo, transa, diag, alpha, a, b)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template
		 }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  report "PLA_Trsm at " ++ @callsite ++ ":\n" ++
    "    Object " ++ [ a ] ++ " is " ++
    RowDistribution : view_a ++ " by " ++
    ColDistribution : view_a ++ "\n" ++
    "    Object " ++ [ b ] ++ " is " ++
    RowDistribution : view_b ++ " by " ++
    ColDistribution : view_b ++ "\n";

  // -- Optimizations

  when (RowDistribution : view_a is-atleast Local ||
	ColDistribution : view_a is-atleast Local ||
	RowDistribution : view_b is-atleast Local ||
	ColDistribution : view_b is-atleast Local)
    inline;

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_b <- Used
  }
}


procedure PLA_Local_trsm(side, uplo, transa, diag, alpha, a, b)
{
  on_entry {

    alpha --> view_alpha { length, width,
			   data --> data_alpha
                           template --> the_template }

    a --> view_a { length, width,
		   data --> data_a
                   template --> the_template }

    b --> view_b { length, width,
		   data --> data_b
                   template --> the_template
		   copy_of --> copied_object --> copied_view
		 }
  }

  access { view_alpha.length, view_alpha.width, data_alpha,
	   view_a.length, view_a.width, data_a,
	   view_b.length, view_b.width, data_b }

  modify { data_b }

  // --Error checking: make sure everything is local or empty

  report if ( ! (RowDistribution : view_a is-atleast Local ||
		 RowDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_a ++ "\n";

  report if ( ! (RowDistribution : view_b is-atleast Local ||
		 RowDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Row distribution is " ++ RowDistribution : view_b ++ "\n";

  report if ( ! (ColDistribution : view_a is-atleast Local ||
		 ColDistribution : view_a is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ a ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_a ++ "\n";

  report if ( ! (ColDistribution : view_b is-atleast Local ||
		 ColDistribution : view_b is-exactly Empty))
    "Error  at " ++ @callsite ++ ": Argument " ++ [ b ] ++ " is not local.\n" ++
      "  Column distribution is " ++ ColDistribution : view_b ++ "\n";


  // -- Make sure alpha and beta are multi-scalars

  report if ( ! ObjType : view_alpha is-exactly Mscalar)
    "Error  at " ++ @callsite ++ ": alpha argument " ++ [ alpha ] ++
      " must be a 1x1 multi-scalar.\n";

  // -- Actions

  when (RowDistribution : view_a is-exactly Empty ||
	ColDistribution : view_a is-exactly Empty ||
	RowDistribution : view_b is-exactly Empty ||
	ColDistribution : view_b is-exactly Empty)
    replace-with %{ ; }%

  report "At " ++ @context ++ ": " ++ [ b ] ++ " is " ++ Copy : view_b ++ "\n";

  when (Copy : view_b is-exactly Identical)
    replace-with %{
      PLA_Local_trsm(${side}, ${uplo}, ${transa}, ${diag}, ${alpha}, ${a}, ${copied_object});
    }%

  // -- Track data use

  analyze DataUsed {
    data_alpha <- Used
    data_a <- Used
    data_b <- Used
  }
}

// ----------------------------------------------------------------------
//  Internal functions
// ----------------------------------------------------------------------

procedure PLA_Gemm_A(nb_alg, transa, transb, 
		     alpha, A, B,
		     beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_B(nb_alg, transa, transb, 
		     alpha, A, B,
		     beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_C(nb_alg, transa, transb, 
		     alpha, A, B,
		     beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_enter(transa, transb, 
			 alpha, A, B, 
			 beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Gemm_exit(transa, transb, 
			alpha, A, B, 
			beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Gemm_matpan(nb_alg, transa, transb, 
			  alpha, A, B,
			  beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_panmat(nb_alg, transa, transb, 
			  alpha, A, B,
			  beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_panpan(nb_alg, transa, transb, 
			  alpha, A, B,
			  beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_x(version, transa, transb, 
		     alpha, A, B, 
		     beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Gemm_x_enter(version, transa, transb, 
			   alpha, A, B, 
			   beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Gemm_x_exit(version, transa, transb, 
			  alpha, A, B, 
			  beta,  C )
{
  when (1==1) replace-with %{ ; }%
}


procedure PLA_Herk_perform_local_part(uplo, 
				      alpha, Xdpmv, 
				      Xdpmv_conj_trans,
				      beta,  A )
{
  modify { SideEffect }
}

procedure PLA_Herk_perform_local_part_by_panels(uplo, 
						alpha, Xdpmv, 
						Xdpmv_conj_trans,
						beta,  A )
{
  modify { SideEffect }
}

procedure PLA_Symm_enter(side, uplo,
			 alpha, A, B, 
			 beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Symm_exit(side, uplo,
			alpha, A, B, 
			beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Syrk_enter (uplo, transa, alpha, A,
			  beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Syrk_exit (uplo, transa, alpha, A,
			 beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Syrk_panpan(nb_alg, uplo, transa,
			  alpha, A, 
			  beta,  C )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Syrk_perform_local_part(uplo, 
				      alpha, Xdpmv, 
				      Xdpmv_trans,
				      beta,  A )
{
  modify { SideEffect }
}

procedure PLA_Syrk_perform_local_part_by_panels(uplo, 
						alpha, Xdpmv, 
						Xdpmv_trans,
						beta,  A )
{
  modify { SideEffect }
}

procedure PLA_Trmm_enter(side, uplo, transa, transb, 
			 alpha, A, B, 
			 beta,  C )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Trmm_exit(side, uplo, transa, diag,
			alpha, A, B )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Trmm_left_lower(transa, diag,
			      alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trmm_left_upper(transa, diag,
			      alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trmm_right_lower(transa, diag,
			       alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trmm_right_upper(transa, diag,
			       alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trsm_enter(side, uplo, transa, diag,
			 alpha, A, B )
{
  when (1==1) replace-with %{ ; }%
}
 
procedure PLA_Trsm_exit(side, uplo, transa, diag,
			alpha, A, B )
{
  when (1==1) replace-with %{ ; }%
}

procedure PLA_Trsm_left_lower(transa, diag,
			      alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trsm_left_upper(transa, diag,
			      alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

procedure PLA_Trsm_right_lower(transa, diag,
			       alpha, A, B )
{
  when (1==1) inline;
  modify { SideEffect }
}

