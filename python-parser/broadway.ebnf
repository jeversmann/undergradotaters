start = annotations:{ annotation }$;

annotation = header | procedure | property | global;

header = '%{' code:{ c_code } '}%';

procedure = 'procedure' ~ name:procname ~ '(' arguments:identifier_list ')' ~ '{'
            statements:{ procedure_annotation } '}';

procedure_annotation = pointer_annotation | dependence_annotation
                     | analysis_rule_annotation | action_annotation | report_annotation;

pointer_annotation = pointer_entry | pointer_exit;
pointer_entry = 'on_entry' ~ '{' entry_pointer:{ pointer_structure } '}';
pointer_exit = 'on_exit' ~ '{' ( cond_pointers:{ cond_pointer_structure }
                               | pointers:{ pointer_structure } ) '}';

cond_pointer_structure = 'if' ~ '(' condition:condition ')' ~
                              '{' structures:{ pointer_structure } '}'
                       | 'default' ~ '{' structures:{ pointer_structure } '}';


pointer_structure = points_to
                  | struct
                  | delete
                  | variable;
variable = [io:'I/O'] name:varname;
points_to = name:varname '-->' ~ new:['new'] target:pointer_structure;
struct = name:varname '{' ~ { members:pointer_structure [','] } '}';
delete = 'delete' ~ name:varname;

dependence_annotation = access | modify;
access = 'access' ~ '{' names:identifier_list '}';
modify = 'modify' ~ '{' names:identifier_list '}';

property = strong_property | weak_property;
strong_property = 'property' ~ @:property_definition;
weak_property = 'weak-property' ~ @:property_definition;
property_definition = name:propname ':' ~ def:(enum_property_definition | set_property_definition);

enum_property_definition = direction:[direction] values:property_values [ initial:initial_value ];

direction = forward | backward;
forward = '@forward';
backward = '@backward';

initial_value = 'default' ~ @:propval;

property_values = '{' @:property_value_list '}';
property_value_list = { @:property_value [ ',' &property_value ] };
property_value = name:propval [ sublist:property_values ];

set_property_definition = '{' set_type:set_type '}';
set_type = union_equivalence:'union-equivalence'
         | intersect_equivalence:'intersect-equivalence'
         | union:'union-set'
         | intersect:'intersect-set';

analysis_rule_annotation = 'analyze' ~ name:propname ~ ( '{' rules:{ analysis_rule } '}'
                                                       | '{' effects:{ analysis_effect } '}');
                         
analysis_rule = if
              | default;
if = 'if' ~ '(' condition:condition ')' ~ '{' effects:{ analysis_effect } '}';
default = 'default' ~ '{' effects:{ analysis_effect } '}';

condition = lhs:cond { operator:('&&' | '||') ~ rhs:cond };
cond = negation | condition_group | test;
negation = operator:'!' ~ lhs:condition_group;
condition_group = '(' ~ @:condition ')';

test = enum_property_test | set_property_test | numeric_test | binding_test;

enum_property_test = enum_unknown_test | enum_operator_test;
enum_unknown_test = [property:varname ':'] name:varname time:[temporal_operator] operator:'is-??';
enum_operator_test = [property:varname ':'] name:varname time:[temporal_operator]
                     operator:enum_property_operator ~ target:varname;

temporal_operator = '@before' | '@after' | '@always' | '@ever';

enum_property_operator = 'is-exactly' | 'is-atleast' | 'could-be' | 'is-atmost';

set_property_test = set_identifier_test | set_element_test | set_empty_test;
set_identifier_test = name1:varname name2:propname name3:varname;
set_element_test = element:varname 'is-element-of' ~ set:varname;
set_empty_test = set:varname 'is-{}';

binding_test = binding_operator_test | binding_empty_test;
binding_operator_test = lhs:varname operator:('is-aliasof'|'is-sameas') ~ rhs:varname;
binding_empty_test = lhs:varname operator:'is-empty';

analysis_effect = numeric_assignment
                | enum_property_assignment
                | set_property_operation;
numeric_assignment = lhs:varname operator:('='!'=') ~ rhs:num_expression;
enum_property_assignment = lhs:varname operator:('<-'|'<-+') ~ rhs:varname;

set_property_operation = set_modify_operation | identifier_operation;
set_modify_operation = operator:('add'|'remove') ~ lhs:varname;
identifier_operation = lhs:varname second:varname third:varname;


report_annotation = report_conditional | report_unconditional | error_conditional
                  | error_unconditional;

report_conditional = 'report' 'if' ~ '(' condition:condition ')' ~ report:report_element_list ';';
report_unconditional = 'report' ~ report:report_element_list ';';
error_conditional = 'error' 'if' ~ '(' condition:condition ')' ~ error:report_element_list ';';
error_unconditional = 'error' ~ error:report_element_list ';';

report_element_list = { elements:report_element [ '++' &report_element ] };

report_element = report_program_location | report_property | report_numeric
               | report_identifier | report_string;
report_property = property:propname ':' name:varname time:[temporal_operator];
report_numeric = expression:num_expression time:[temporal_operator];
report_identifier = '[' name:varname ']';
report_program_location = location:callsite | location:context;
callsite = '@callsite';
context = '@context';
report_string = string:string;


action_annotation = action:replace | action:inline;
replace = 'when' '(' condition:condition ')' 'replace-with' '%{' code:c_code '}%';
inline = 'when' '(' condition:condition ')' 'inline' ';';


global = global_pointer | analysis_rule_annotation;
global_pointer = 'global' ~ '{' { @:pointer_structure [ ',' ] } '}';


numeric_test = num_compare_expression | numeric_is_number;
numeric_is_number = lhs:propname operator:'is-#';
num_compare_expression = lhs:num_expression operator:compare_operator ~ rhs:num_expression;
compare_operator = '=='|'!='|'<='|'>='|'<'|'>';

num_expression = bitwise_expression;
bitwise_expression = lhs:sum_expression { operator:('|' !'|' | '&' !'&' | '^') ~ rhs:sum_expression };
sum_expression = lhs:mult_expression { operator:('+' !'+' | '-') ~ rhs:mult_expression };
mult_expression = lhs:factor { operator:('*'|'/'|'%') ~ rhs:factor };
factor = lhs:group_expression | lhs:number | lhs:varname;
group_expression = '(' ~ @:num_expression ')';

propname = identifier;
procname = identifier;
propval = identifier;
varname = identifier;
number = /((\d+(\.\d*)?)|(\.\d+))/;
string = /\".+?\"/;
c_code = /([^}]|}(?!%))+/;
identifier = /[a-zA-Z][\w\.]*/;

identifier_list = { @+:procname [ ',' &procname ] };
