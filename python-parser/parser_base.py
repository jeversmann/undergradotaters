#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser


__version__ = (2015, 5, 5, 4, 58, 6, 1)

__all__ = [
    'BroadwayParser',
    'BroadwaySemantics',
    'main'
]


class BroadwayParser(Parser):
    def __init__(self, whitespace=None, nameguard=True, **kwargs):
        super(BroadwayParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=None,
            eol_comments_re=None,
            **kwargs
        )

    @graken()
    def _start_(self):

        def block1():
            self._annotation_()
        self._closure(block1)
        self.ast.setlist('annotations', self.last_node)

        self.ast._define(
            [],
            ['annotations']
        )

    @graken()
    def _annotation_(self):
        with self._choice():
            with self._option():
                self._header_()
            with self._option():
                self._property_()
            with self._option():
                self._procedure_()
            self._error('no available options')

    @graken()
    def _header_(self):
        self._token('%{')
        self._c_code_()
        self.ast['code'] = self.last_node
        self._token('}%')

        self.ast._define(
            ['code'],
            []
        )

    @graken()
    def _global_(self):
        pass

    @graken()
    def _procedure_(self):
        self._token('procedure')
        self._procname_()
        self.ast['name'] = self.last_node
        self._token('(')
        self._identifier_list_()
        self.ast['arguments'] = self.last_node
        self._token(')')
        self._token('{')

        def block3():
            self._statement_()
        self._closure(block3)
        self.ast.setlist('statements', self.last_node)
        self._token('}')

        self.ast._define(
            ['name', 'arguments'],
            ['statements']
        )

    @graken()
    def _statement_(self):
        with self._choice():
            with self._option():
                self._pointers_()
            with self._option():
                self._usedefs_()
            with self._option():
                self._analyze_()
            with self._option():
                self._transform_()
            with self._option():
                self._report_()
            self._error('no available options')

    @graken()
    def _pointers_(self):
        with self._choice():
            with self._option():
                self._token('on_entry')
                self._token('{')

                def block1():
                    self._structure_()
                self._closure(block1)
                self.ast.setlist('entries', self.last_node)
                self._token('}')
            with self._option():
                self._token('on_exit')
                self._token('{')

                def block3():
                    self._structure_()
                self._closure(block3)
                self.ast.setlist('exits', self.last_node)
                self._token('}')
            self._error('expecting one of: on_entry on_exit')

        self.ast._define(
            [],
            ['entries', 'exits']
        )

    @graken()
    def _structure_(self):
        with self._choice():
            with self._option():
                self._points_to_()
            with self._option():
                self._struct_()
            with self._option():
                self._delete_()
            with self._option():
                self._variable_()
            self._error('no available options')

    @graken()
    def _variable_(self):
        self._varname_()
        self.ast['name'] = self.last_node

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _points_to_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('-->')
        with self._optional():
            self._token('new')
        self.ast['new'] = self.last_node
        self._structure_()
        self.ast['target'] = self.last_node

        self.ast._define(
            ['name', 'new', 'target'],
            []
        )

    @graken()
    def _struct_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('{')

        def block2():
            self._structure_()
        self._closure(block2)
        self.ast.setlist('members', self.last_node)
        self._token('}')

        self.ast._define(
            ['name'],
            ['members']
        )

    @graken()
    def _delete_(self):
        self._token('delete')
        self._varname_()
        self.ast['name'] = self.last_node

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _usedefs_(self):
        with self._choice():
            with self._option():
                self._access_()
            with self._option():
                self._modify_()
            self._error('no available options')

    @graken()
    def _access_(self):
        self._token('access')
        self._token('{')
        self._identifier_list_()
        self.ast['names'] = self.last_node
        self._token('}')

        self.ast._define(
            ['names'],
            []
        )

    @graken()
    def _modify_(self):
        self._token('modify')
        self._token('{')
        self._identifier_list_()
        self.ast['names'] = self.last_node
        self._token('}')

        self.ast._define(
            ['names'],
            []
        )

    @graken()
    def _property_(self):
        self._token('property')
        self._propname_()
        self.ast['name'] = self.last_node
        self._token(':')
        with self._optional():
            self._dir_()
        self.ast['direction'] = self.last_node
        self._token('{')

        def block3():
            self._property_vals_()
        self._closure(block3)
        self.ast.setlist('values', self.last_node)
        self._token('}')
        with self._optional():
            self._token('initially')
            self._propval_()
            self.ast['initial'] = self.last_node

        self.ast._define(
            ['name', 'direction', 'initial'],
            ['values']
        )

    @graken()
    def _property_vals_(self):
        self._token('{')
        self._property_val_list_()
        self.ast['values'] = self.last_node
        self._token('}')

        self.ast._define(
            ['values'],
            []
        )

    @graken()
    def _property_val_list_(self):
        self._property_val_()
        self.ast['value'] = self.last_node
        with self._optional():
            self._token(',')
            self._property_val_list_()
            self.ast['rest'] = self.last_node

        self.ast._define(
            ['value', 'rest'],
            []
        )

    @graken()
    def _property_val_(self):
        self._propval_()
        self.ast['value'] = self.last_node
        with self._optional():
            self._property_vals_()
            self.ast['sublist'] = self.last_node

        self.ast._define(
            ['value', 'sublist'],
            []
        )

    @graken()
    def _dir_(self):
        with self._choice():
            with self._option():
                self._forward_()
            with self._option():
                self._backward_()
            self._error('no available options')

    @graken()
    def _forward_(self):
        self._token('@forward')

    @graken()
    def _backward_(self):
        self._token('@backward')

    @graken()
    def _analyze_(self):
        with self._choice():
            with self._option():
                self._token('analyze')
                self._propname_()
                self.ast['name'] = self.last_node
                self._token('{')

                def block2():
                    self._analysis_rule_()
                self._closure(block2)
                self.ast.setlist('rules', self.last_node)
                self._token('}')
            with self._option():
                self._token('analyze')
                self._propname_()
                self.ast['name'] = self.last_node
                self._token('{')

                def block5():
                    self._effect_()
                self._closure(block5)
                self.ast.setlist('effects', self.last_node)
                self._token('}')
            self._error('no available options')

        self.ast._define(
            ['name'],
            ['rules', 'effects']
        )

    @graken()
    def _analysis_rule_(self):
        with self._choice():
            with self._option():
                self._if_()
            with self._option():
                self._default_()
            self._error('no available options')

    @graken()
    def _if_(self):
        self._token('if')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('{')

        def block2():
            self._effect_()
        self._closure(block2)
        self.ast.setlist('effects', self.last_node)
        self._token('}')

        self.ast._define(
            ['condition'],
            ['effects']
        )

    @graken()
    def _default_(self):
        self._token('default')
        self._token('{')

        def block1():
            self._effect_()
        self._closure(block1)
        self.ast.setlist('effects', self.last_node)
        self._token('}')

        self.ast._define(
            [],
            ['effects']
        )

    @graken()
    def _condition_(self):
        with self._choice():
            with self._option():
                self._numeric_comparison_()
            with self._option():
                self._disjunction_()
            with self._option():
                self._conjunction_()
            with self._option():
                self._negation_()
            with self._option():
                self._condition_test_()
            self._error('no available options')

    @graken()
    def _condition_test_(self):
        with self._optional():
            self._propname_()
            self.ast['property'] = self.last_node
            self._token(':')
        self._test_()

        self.ast._define(
            ['property'],
            []
        )

    @graken()
    def _disjunction_(self):
        self._condition_()
        self.ast['lhs'] = self.last_node
        self._token('||')
        self._condition_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _conjunction_(self):
        self._condition_()
        self.ast['lhs'] = self.last_node
        self._token('&&')
        self._condition_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _negation_(self):
        self._token('!')
        self._condition_()
        self.ast['condition'] = self.last_node

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _numeric_comparison_(self):
        with self._choice():
            with self._option():
                self._num_compare_expression_()
            with self._option():
                self._numeric_is_comparison_()
            self._error('no available options')

    @graken()
    def _numeric_is_comparison_(self):
        self._propname_()
        self.ast['name'] = self.last_node
        self._token('is-')
        self._number_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _num_compare_expression_(self):
        with self._choice():
            with self._option():
                self._equal_to_()
            with self._option():
                self._not_equal_to_()
            with self._option():
                self._less_than_()
            with self._option():
                self._greater_than_()
            with self._option():
                self._less_or_equal_()
            with self._option():
                self._greater_or_equal_()
            self._error('no available options')

    @graken()
    def _equal_to_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('==')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _not_equal_to_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('!=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _less_than_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('<')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _greater_than_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('>')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _less_or_equal_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('<=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _greater_or_equal_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('>=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _num_expression_(self):
        with self._choice():
            with self._option():
                self._propname_()
            with self._option():
                self._sub_expression_()
            with self._option():
                self._plus_expression_()
            with self._option():
                self._minus_expression_()
            with self._option():
                self._or_expression_()
            with self._option():
                self._xor_expression_()
            with self._option():
                self._and_expression_()
            with self._option():
                self._mult_expression_()
            with self._option():
                self._div_expression_()
            with self._option():
                self._mod_expression_()
            with self._option():
                self._positive_expression_()
            with self._option():
                self._negative_expression_()
            with self._option():
                self._number_()
            self._error('no available options')

    @graken()
    def _sub_expression_(self):
        self._token('(')
        self._num_expression_()
        self.ast['@'] = self.last_node
        self._token(')')

    @graken()
    def _plus_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('+')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _minus_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('-')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _or_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('|')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _xor_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('^')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _and_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('&')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _mult_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('*')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _div_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('/')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _mod_expression_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('%')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _positive_expression_(self):
        self._token('+')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['rhs'],
            []
        )

    @graken()
    def _negative_expression_(self):
        self._token('-')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['rhs'],
            []
        )

    @graken()
    def _test_(self):
        with self._choice():
            with self._option():
                self._bottom_test_()
            with self._option():
                self._exactly_test_()
            with self._option():
                self._atleast_test_()
            with self._option():
                self._could_be_test_()
            with self._option():
                self._atmost_test_()
            self._error('no available options')

    @graken()
    def _bottom_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-??')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _exactly_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-exactly')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _atleast_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-atleast')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _could_be_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('could-be')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _atmost_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-atmost')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _effect_(self):
        with self._choice():
            with self._option():
                self._varname_()
                self.ast['target'] = self.last_node
                self._token('<-')
                self._propval_()
                self.ast['value'] = self.last_node
            with self._option():
                self._varname_()
                self.ast['target'] = self.last_node
                self._token('<-')
                self._varname_()
                self.ast['source'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['target', 'value', 'source'],
            []
        )

    @graken()
    def _transform_(self):
        with self._choice():
            with self._option():
                self._replace_()
            with self._option():
                self._inline_()
            self._error('no available options')

    @graken()
    def _replace_(self):
        self._token('when')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('replace-with')
        self._token('%{')
        self._c_code_()
        self.ast['code'] = self.last_node
        self._token('%}')

        self.ast._define(
            ['condition', 'code'],
            []
        )

    @graken()
    def _inline_(self):
        self._token('when')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('inline')
        self._token(';')

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _report_(self):
        self._token('report')
        self._token('if')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')

        def block2():
            self._report_element_()
        self._closure(block2)
        self.ast.setlist('report_elements', self.last_node)
        self._token(';')

        self.ast._define(
            ['condition'],
            ['report_elements']
        )

    @graken()
    def _report_element_(self):
        with self._choice():
            with self._option():
                self._concat_()
            with self._option():
                self._callsite_()
            with self._option():
                self._report_var_()
            with self._option():
                self._string_()
            self._error('no available options')

    @graken()
    def _concat_(self):
        self._report_element_()
        self.ast['lhs'] = self.last_node
        self._token('++')
        self._report_element_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _callsite_(self):
        self._token('@callsite')

    @graken()
    def _report_var_(self):
        self._token('[')
        self._varname_()
        self.ast['name'] = self.last_node
        self._token(']')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _identifier_list_(self):
        self._procname_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._token(',')
            self._identifier_list_()
            self.ast['rest'] = self.last_node

        self.ast._define(
            ['name', 'rest'],
            []
        )

    @graken()
    def _propname_(self):
        self._pattern(r'\w+')

    @graken()
    def _procname_(self):
        self._pattern(r'\w+')

    @graken()
    def _propval_(self):
        self._pattern(r'\w+')

    @graken()
    def _varname_(self):
        self._pattern(r'\w+')

    @graken()
    def _number_(self):
        self._pattern(r'\d*\.?\d*')

    @graken()
    def _string_(self):
        self._pattern(r'\".+\"')

    @graken()
    def _c_code_(self):
        self._pattern(r'.+')


class BroadwaySemantics(object):
    def start(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def header(self, ast):
        return ast

    def global_(self, ast):
        return ast

    def procedure(self, ast):
        return ast

    def statement(self, ast):
        return ast

    def pointers(self, ast):
        return ast

    def structure(self, ast):
        return ast

    def variable(self, ast):
        return ast

    def points_to(self, ast):
        return ast

    def struct(self, ast):
        return ast

    def delete(self, ast):
        return ast

    def usedefs(self, ast):
        return ast

    def access(self, ast):
        return ast

    def modify(self, ast):
        return ast

    def property(self, ast):
        return ast

    def property_vals(self, ast):
        return ast

    def property_val_list(self, ast):
        return ast

    def property_val(self, ast):
        return ast

    def dir(self, ast):
        return ast

    def forward(self, ast):
        return ast

    def backward(self, ast):
        return ast

    def analyze(self, ast):
        return ast

    def analysis_rule(self, ast):
        return ast

    def if_(self, ast):
        return ast

    def default(self, ast):
        return ast

    def condition(self, ast):
        return ast

    def condition_test(self, ast):
        return ast

    def disjunction(self, ast):
        return ast

    def conjunction(self, ast):
        return ast

    def negation(self, ast):
        return ast

    def numeric_comparison(self, ast):
        return ast

    def numeric_is_comparison(self, ast):
        return ast

    def num_compare_expression(self, ast):
        return ast

    def equal_to(self, ast):
        return ast

    def not_equal_to(self, ast):
        return ast

    def less_than(self, ast):
        return ast

    def greater_than(self, ast):
        return ast

    def less_or_equal(self, ast):
        return ast

    def greater_or_equal(self, ast):
        return ast

    def num_expression(self, ast):
        return ast

    def sub_expression(self, ast):
        return ast

    def plus_expression(self, ast):
        return ast

    def minus_expression(self, ast):
        return ast

    def or_expression(self, ast):
        return ast

    def xor_expression(self, ast):
        return ast

    def and_expression(self, ast):
        return ast

    def mult_expression(self, ast):
        return ast

    def div_expression(self, ast):
        return ast

    def mod_expression(self, ast):
        return ast

    def positive_expression(self, ast):
        return ast

    def negative_expression(self, ast):
        return ast

    def test(self, ast):
        return ast

    def bottom_test(self, ast):
        return ast

    def exactly_test(self, ast):
        return ast

    def atleast_test(self, ast):
        return ast

    def could_be_test(self, ast):
        return ast

    def atmost_test(self, ast):
        return ast

    def effect(self, ast):
        return ast

    def transform(self, ast):
        return ast

    def replace(self, ast):
        return ast

    def inline(self, ast):
        return ast

    def report(self, ast):
        return ast

    def report_element(self, ast):
        return ast

    def concat(self, ast):
        return ast

    def callsite(self, ast):
        return ast

    def report_var(self, ast):
        return ast

    def identifier_list(self, ast):
        return ast

    def propname(self, ast):
        return ast

    def procname(self, ast):
        return ast

    def propval(self, ast):
        return ast

    def varname(self, ast):
        return ast

    def number(self, ast):
        return ast

    def string(self, ast):
        return ast

    def c_code(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None, nameguard=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = BroadwayParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in BroadwayParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for Broadway.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-n', '--no-nameguard', action='store_true',
                        dest='no_nameguard',
                        help="disable the 'nameguard' feature")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(
        args.file,
        args.startrule,
        trace=args.trace,
        whitespace=args.whitespace,
        nameguard=not args.no_nameguard
    )
