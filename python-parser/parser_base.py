#!/usr/bin/env python
# -*- coding: utf-8 -*-

# CAVEAT UTILITOR
#
# This file was automatically generated by Grako.
#
#    https://pypi.python.org/pypi/grako/
#
# Any changes you make to it will be overwritten the next time
# the file is generated.


from __future__ import print_function, division, absolute_import, unicode_literals
from grako.parsing import graken, Parser
from grako.util import re, RE_FLAGS


__version__ = (2015, 5, 15, 3, 7, 40, 4)

__all__ = [
    'BroadwayParser',
    'BroadwaySemantics',
    'main'
]


class BroadwayParser(Parser):
    def __init__(self, whitespace=None, nameguard=None, **kwargs):
        super(BroadwayParser, self).__init__(
            whitespace=whitespace,
            nameguard=nameguard,
            comments_re=None,
            eol_comments_re=None,
            ignorecase=None,
            **kwargs
        )

    @graken()
    def _start_(self):

        def block1():
            self._annotation_()
        self._closure(block1)
        self.ast['annotations'] = self.last_node

        self.ast._define(
            ['annotations'],
            []
        )

    @graken()
    def _annotation_(self):
        with self._choice():
            with self._option():
                self._header_()
            with self._option():
                self._procedure_()
            with self._option():
                self._property_()
            with self._option():
                self._global_()
            self._error('no available options')

    @graken()
    def _header_(self):
        self._token('%{')

        def block1():
            self._c_code_()
        self._closure(block1)
        self.ast['code'] = self.last_node
        self._token('}%')

        self.ast._define(
            ['code'],
            []
        )

    @graken()
    def _procedure_(self):
        self._token('procedure')
        self._procname_()
        self.ast['name'] = self.last_node
        self._token('(')
        self._identifier_list_()
        self.ast['arguments'] = self.last_node
        self._token(')')
        self._token('{')

        def block3():
            self._procedure_annotation_()
        self._closure(block3)
        self.ast['statements'] = self.last_node
        self._token('}')

        self.ast._define(
            ['name', 'arguments', 'statements'],
            []
        )

    @graken()
    def _procedure_annotation_(self):
        with self._choice():
            with self._option():
                self._pointer_annotation_()
            with self._option():
                self._dependence_annotation_()
            with self._option():
                self._analysis_rule_annotation_()
            with self._option():
                self._action_annotation_()
            with self._option():
                self._report_annotation_()
            self._error('no available options')

    @graken()
    def _pointer_annotation_(self):
        with self._choice():
            with self._option():
                self._token('on_entry')
                self._token('{')

                def block1():
                    self._pointer_structure_()
                self._closure(block1)
                self.ast['entries'] = self.last_node
                self._token('}')
            with self._option():
                self._token('on_exit')
                self._token('{')

                def block3():
                    self._pointer_structure_()
                self._closure(block3)
                self.ast['exits'] = self.last_node
                self._token('}')
            with self._option():
                self._token('on_exit')
                self._token('{')

                def block5():
                    self._cond_pointer_structure_()
                self._closure(block5)
                self.ast['exits'] = self.last_node
                self._token('}')
            self._error('expecting one of: on_entry on_exit')

        self.ast._define(
            ['entries', 'exits'],
            []
        )

    @graken()
    def _cond_pointer_structure_(self):
        with self._choice():
            with self._option():
                self._token('if')
                self._token('(')
                self._condition_()
                self.ast['condition'] = self.last_node
                self._token(')')
                self._token('{')

                def block2():
                    self._pointer_structure_()
                self._closure(block2)
                self.ast['structures'] = self.last_node
                self._token('}')
            with self._option():
                self._token('default')
                self._token('{')

                def block4():
                    self._pointer_structure_()
                self._closure(block4)
                self.ast['structures'] = self.last_node
                self._token('}')
            self._error('expecting one of: default')

        self.ast._define(
            ['condition', 'structures'],
            []
        )

    @graken()
    def _pointer_structure_(self):
        with self._choice():
            with self._option():
                self._points_to_()
            with self._option():
                self._struct_()
            with self._option():
                self._delete_()
            with self._option():
                self._variable_()
            self._error('no available options')

    @graken()
    def _variable_(self):
        with self._optional():
            self._token('I/O')
            self.ast['io'] = self.last_node
        self._varname_()
        self.ast['name'] = self.last_node

        self.ast._define(
            ['io', 'name'],
            []
        )

    @graken()
    def _points_to_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('-->')
        with self._optional():
            self._token('new')
        self.ast['new'] = self.last_node
        self._pointer_structure_()
        self.ast['target'] = self.last_node

        self.ast._define(
            ['name', 'new', 'target'],
            []
        )

    @graken()
    def _struct_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('{')

        def block2():
            self._pointer_structure_()
            with self._optional():
                self._token(',')
        self._closure(block2)
        self.ast['members'] = self.last_node
        self._token('}')

        self.ast._define(
            ['name', 'members'],
            []
        )

    @graken()
    def _delete_(self):
        self._token('delete')
        self._varname_()
        self.ast['name'] = self.last_node

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _dependence_annotation_(self):
        with self._choice():
            with self._option():
                self._access_()
            with self._option():
                self._modify_()
            self._error('no available options')

    @graken()
    def _access_(self):
        self._token('access')
        self._token('{')
        self._identifier_list_()
        self.ast['names'] = self.last_node
        self._token('}')

        self.ast._define(
            ['names'],
            []
        )

    @graken()
    def _modify_(self):
        self._token('modify')
        self._token('{')
        self._identifier_list_()
        self.ast['names'] = self.last_node
        self._token('}')

        self.ast._define(
            ['names'],
            []
        )

    @graken()
    def _property_(self):
        with self._choice():
            with self._option():
                self._strong_property_()
            with self._option():
                self._weak_property_()
            self._error('no available options')

    @graken()
    def _strong_property_(self):
        self._token('property')
        self._property_definition_()
        self.ast['@'] = self.last_node

    @graken()
    def _weak_property_(self):
        self._token('weak-property')
        self._property_definition_()
        self.ast['@'] = self.last_node

    @graken()
    def _property_definition_(self):
        with self._choice():
            with self._option():
                self._propname_()
                self.ast['name'] = self.last_node
                self._token(':')
                self._enum_property_definition_()
                self.ast['def_'] = self.last_node
            with self._option():
                self._propname_()
                self.ast['name'] = self.last_node
                self._token(':')
                self._set_property_definition_()
                self.ast['def_'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['name', 'def'],
            []
        )

    @graken()
    def _enum_property_definition_(self):
        with self._optional():
            self._direction_()
        self.ast['direction'] = self.last_node
        self._property_values_()
        self.ast.setlist('values', self.last_node)
        with self._optional():
            self._initial_value_()
            self.ast['initial'] = self.last_node

        self.ast._define(
            ['direction', 'initial'],
            ['values']
        )

    @graken()
    def _direction_(self):
        with self._choice():
            with self._option():
                self._forward_()
            with self._option():
                self._backward_()
            self._error('no available options')

    @graken()
    def _forward_(self):
        self._token('@forward')

    @graken()
    def _backward_(self):
        self._token('@backward')

    @graken()
    def _initial_value_(self):
        self._token('default')
        self._propval_()
        self.ast['name'] = self.last_node

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _property_values_(self):
        self._token('{')
        self._property_value_list_()
        self.ast['values'] = self.last_node
        self._token('}')

        self.ast._define(
            ['values'],
            []
        )

    @graken()
    def _property_value_list_(self):

        def block0():
            self._property_value_()
            self.ast['values'] = self.last_node
            with self._optional():
                self._token(',')
                with self._if():
                    self._property_value_()
        self._closure(block0)

        self.ast._define(
            ['values'],
            []
        )

    @graken()
    def _property_value_(self):
        self._propval_()
        self.ast['value'] = self.last_node
        with self._optional():
            self._property_values_()
            self.ast['sublist'] = self.last_node

        self.ast._define(
            ['value', 'sublist'],
            []
        )

    @graken()
    def _set_property_definition_(self):
        self._token('{')
        self._set_type_()
        self.ast['type'] = self.last_node
        self._token('}')

        self.ast._define(
            ['type'],
            []
        )

    @graken()
    def _set_type_(self):
        with self._choice():
            with self._option():
                self._token('union-equivalence')
                self.ast['union_equivalence'] = self.last_node
            with self._option():
                self._token('intersect-equivalence')
                self.ast['intersect_equivalence'] = self.last_node
            with self._option():
                self._token('union-set')
                self.ast['union'] = self.last_node
            with self._option():
                self._token('intersect-set')
                self.ast['intersect'] = self.last_node
            self._error('expecting one of: intersect-equivalence intersect-set union-equivalence union-set')

        self.ast._define(
            ['union_equivalence', 'intersect_equivalence', 'union', 'intersect'],
            []
        )

    @graken()
    def _analysis_rule_annotation_(self):
        with self._choice():
            with self._option():
                self._token('analyze')
                self._propname_()
                self.ast['name'] = self.last_node
                self._token('{')

                def block2():
                    self._analysis_rule_()
                self._closure(block2)
                self.ast['rules'] = self.last_node
                self._token('}')
            with self._option():
                self._token('analyze')
                self._propname_()
                self.ast['name'] = self.last_node
                self._token('{')

                def block5():
                    self._analysis_effect_()
                self._closure(block5)
                self.ast['effects'] = self.last_node
                self._token('}')
            self._error('no available options')

        self.ast._define(
            ['name', 'rules', 'effects'],
            []
        )

    @graken()
    def _analysis_rule_(self):
        with self._choice():
            with self._option():
                self._if_()
            with self._option():
                self._default_()
            self._error('no available options')

    @graken()
    def _if_(self):
        self._token('if')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('{')

        def block2():
            self._analysis_effect_()
        self._closure(block2)
        self.ast['effects'] = self.last_node
        self._token('}')

        self.ast._define(
            ['condition', 'effects'],
            []
        )

    @graken()
    def _default_(self):
        self._token('default')
        self._token('{')

        def block1():
            self._analysis_effect_()
        self._closure(block1)
        self.ast['effects'] = self.last_node
        self._token('}')

        self.ast._define(
            ['effects'],
            []
        )

    @graken()
    def _condition_(self):
        self._conjunction_()

    @graken()
    def _conjunction_(self):

        def block0():
            self._disjunction_()
            self.ast['terms'] = self.last_node
            with self._optional():
                self._token('&&')
                with self._if():
                    self._disjunction_()
        self._closure(block0)

        self.ast._define(
            ['terms'],
            []
        )

    @graken()
    def _disjunction_(self):

        def block0():
            self._cond_()
            self.ast['terms'] = self.last_node
            with self._optional():
                self._token('||')
                with self._if():
                    self._cond_()
        self._closure(block0)

        self.ast._define(
            ['terms'],
            []
        )

    @graken()
    def _negation_(self):
        self._token('!')
        self._condition_group_()
        self.ast['condition'] = self.last_node

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _cond_(self):
        with self._choice():
            with self._option():
                self._negation_()
            with self._option():
                self._condition_group_()
            with self._option():
                self._test_()
            self._error('no available options')

    @graken()
    def _condition_group_(self):
        self._token('(')
        self._condition_()
        self.ast['@'] = self.last_node
        self._token(')')

    @graken()
    def _test_(self):
        with self._choice():
            with self._option():
                self._enum_property_test_()
            with self._option():
                self._set_property_test_()
            with self._option():
                self._numeric_test_()
            with self._option():
                self._binding_test_()
            self._error('no available options')

    @graken()
    def _enum_property_test_(self):
        with self._choice():
            with self._option():
                self._enum_unknown_test_()
            with self._option():
                self._enum_operator_test_()
            self._error('no available options')

    @graken()
    def _enum_unknown_test_(self):
        with self._optional():
            self._varname_()
            self.ast['property'] = self.last_node
            self._token(':')
        self._varname_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._temporal_operator_()
        self.ast['time'] = self.last_node
        self._token('is-??')

        self.ast._define(
            ['property', 'name', 'time'],
            []
        )

    @graken()
    def _enum_operator_test_(self):
        with self._optional():
            self._varname_()
            self.ast['property'] = self.last_node
            self._token(':')
        self._varname_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._temporal_operator_()
        self.ast['time'] = self.last_node
        self._enum_property_operator_()
        self.ast['operator'] = self.last_node
        self._varname_()
        self.ast['target'] = self.last_node

        self.ast._define(
            ['property', 'name', 'time', 'operator', 'target'],
            []
        )

    @graken()
    def _temporal_operator_(self):
        with self._choice():
            with self._option():
                self._token('@before')
            with self._option():
                self._token('@after')
            with self._option():
                self._token('@always')
            with self._option():
                self._token('@ever')
            self._error('expecting one of: @after @always @before @ever')

    @graken()
    def _enum_property_operator_(self):
        with self._choice():
            with self._option():
                self._token('is-exactly')
            with self._option():
                self._token('is-atleast')
            with self._option():
                self._token('could-be')
            with self._option():
                self._token('is-atmost')
            self._error('expecting one of: could-be is-atleast is-atmost is-exactly')

    @graken()
    def _set_property_test_(self):
        with self._choice():
            with self._option():
                self._set_identifier_test_()
            with self._option():
                self._set_element_test_()
            with self._option():
                self._set_empty_test_()
            self._error('no available options')

    @graken()
    def _set_identifier_test_(self):
        self._varname_()
        self.ast['name1'] = self.last_node
        self._propname_()
        self.ast['name2'] = self.last_node
        self._varname_()
        self.ast['name3'] = self.last_node

        self.ast._define(
            ['name1', 'name2', 'name3'],
            []
        )

    @graken()
    def _set_element_test_(self):
        self._varname_()
        self.ast['element'] = self.last_node
        self._token('is-element-of')
        self._varname_()
        self.ast['set'] = self.last_node

        self.ast._define(
            ['element', 'set'],
            []
        )

    @graken()
    def _set_empty_test_(self):
        self._varname_()
        self.ast['set'] = self.last_node
        self._token('is-{}')

        self.ast._define(
            ['set'],
            []
        )

    @graken()
    def _binding_test_(self):
        with self._choice():
            with self._option():
                self._binding_alias_test_()
            with self._option():
                self._binding_sameas_test_()
            with self._option():
                self._binding_empty_test_()
            self._error('no available options')

    @graken()
    def _binding_alias_test_(self):
        self._varname_()
        self.ast['lhs'] = self.last_node
        self._token('is-aliasof')
        self._varname_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _binding_sameas_test_(self):
        self._varname_()
        self.ast['lhs'] = self.last_node
        self._token('is-sameas')
        self._varname_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _binding_empty_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-empty')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _analysis_effect_(self):
        with self._choice():
            with self._option():
                self._numeric_assignment_()
            with self._option():
                self._enum_property_assignment_()
            with self._option():
                self._set_property_operation_()
            self._error('no available options')

    @graken()
    def _numeric_assignment_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('=')
        self._num_expression_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _enum_property_assignment_(self):
        with self._choice():
            with self._option():
                self._enum_append_()
            with self._option():
                self._enum_assignment_()
            self._error('no available options')

    @graken()
    def _enum_assignment_(self):
        self._varname_()
        self.ast['lhs'] = self.last_node
        self._token('<-')
        self._varname_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _enum_append_(self):
        self._varname_()
        self.ast['lhs'] = self.last_node
        self._token('<-+')
        self._varname_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _set_property_operation_(self):
        with self._choice():
            with self._option():
                self._add_operation_()
            with self._option():
                self._remove_operation_()
            with self._option():
                self._identifier_operation_()
            self._error('no available options')

    @graken()
    def _add_operation_(self):
        self._token('add')
        self._propname_()

    @graken()
    def _remove_operation_(self):
        self._token('remove')
        self._propname_()

    @graken()
    def _identifier_operation_(self):
        self._varname_()
        self._propname_()
        self._varname_()

    @graken()
    def _report_annotation_(self):
        with self._choice():
            with self._option():
                self._report_conditional_()
            with self._option():
                self._report_unconditional_()
            with self._option():
                self._error_conditional_()
            with self._option():
                self._error_unconditional_()
            self._error('no available options')

    @graken()
    def _report_conditional_(self):
        self._token('report')
        self._token('if')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._report_element_list_()
        self._token(';')

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _report_unconditional_(self):
        self._token('report')
        self._report_element_list_()
        self._token(';')

    @graken()
    def _error_conditional_(self):
        self._token('error')
        self._token('if')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._report_element_list_()
        self._token(';')

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _error_unconditional_(self):
        self._token('error')
        self._report_element_list_()
        self._token(';')

    @graken()
    def _report_element_list_(self):

        def block0():
            self._report_element_()
            self.ast['elements'] = self.last_node
            with self._optional():
                self._token('++')
                with self._if():
                    self._report_element_()
        self._closure(block0)

        self.ast._define(
            ['elements'],
            []
        )

    @graken()
    def _report_element_(self):
        with self._choice():
            with self._option():
                self._report_property_()
            with self._option():
                self._report_numeric_()
            with self._option():
                self._report_program_location_()
            with self._option():
                self._report_identifier_()
            with self._option():
                self._string_()
            self._error('no available options')

    @graken()
    def _report_property_(self):
        self._propname_()
        self.ast['property'] = self.last_node
        self._token(':')
        self._varname_()
        self.ast['name'] = self.last_node
        with self._optional():
            self._temporal_operator_()
        self.ast['time'] = self.last_node

        self.ast._define(
            ['property', 'name', 'time'],
            []
        )

    @graken()
    def _report_numeric_(self):
        self._num_expression_()
        with self._optional():
            self._temporal_operator_()
        self.ast['time'] = self.last_node

        self.ast._define(
            ['time'],
            []
        )

    @graken()
    def _report_identifier_(self):
        self._token('[')
        self._varname_()
        self.ast['name'] = self.last_node
        self._token(']')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _report_program_location_(self):
        with self._choice():
            with self._option():
                self._callsite_()
            with self._option():
                self._context_()
            self._error('no available options')

    @graken()
    def _callsite_(self):
        self._token('@callsite')

    @graken()
    def _context_(self):
        self._token('@context')

    @graken()
    def _action_annotation_(self):
        with self._choice():
            with self._option():
                self._replace_()
            with self._option():
                self._inline_()
            self._error('no available options')

    @graken()
    def _replace_(self):
        self._token('when')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('replace-with')
        self._token('%{')
        self._c_code_()
        self.ast['code'] = self.last_node
        self._token('}%')

        self.ast._define(
            ['condition', 'code'],
            []
        )

    @graken()
    def _inline_(self):
        self._token('when')
        self._token('(')
        self._condition_()
        self.ast['condition'] = self.last_node
        self._token(')')
        self._token('inline')
        self._token(';')

        self.ast._define(
            ['condition'],
            []
        )

    @graken()
    def _global_(self):
        with self._group():
            with self._choice():
                with self._option():
                    self._global_pointer_()
                with self._option():
                    self._analysis_rule_annotation_()
                self._error('no available options')

    @graken()
    def _global_pointer_(self):
        self._token('global')
        self._token('{')

        def block0():
            self._pointer_structure_()
            self.ast.setlist('structures', self.last_node)
            with self._optional():
                self._token(',')
        self._closure(block0)
        self._token('}')

        self.ast._define(
            [],
            ['structures']
        )

    @graken()
    def _identifier_list_(self):

        def block0():
            self._procname_()
            self.ast['names'] = self.last_node
            with self._optional():
                self._token(',')
                with self._if():
                    self._procname_()
        self._closure(block0)

        self.ast._define(
            ['names'],
            []
        )

    @graken()
    def _propname_(self):
        self._identifier_()

    @graken()
    def _procname_(self):
        self._identifier_()

    @graken()
    def _propval_(self):
        self._identifier_()

    @graken()
    def _varname_(self):
        self._identifier_()

    @graken()
    def _number_(self):
        self._pattern(r'((\d+(\.\d*)?)|(\.\d+))')

    @graken()
    def _string_(self):
        self._pattern(r'\".+\"')

    @graken()
    def _c_code_(self):
        self._pattern(r'([^}]|}(?!%))+')

    @graken()
    def _identifier_(self):
        self._pattern(r'[\w\.]+')

    @graken()
    def _bottom_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-??')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _exactly_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-exactly')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _atleast_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-atleast')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _could_be_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('could-be')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _atmost_test_(self):
        self._varname_()
        self.ast['name'] = self.last_node
        self._token('is-atmost')
        self._propval_()
        self.ast['value'] = self.last_node

        self.ast._define(
            ['name', 'value'],
            []
        )

    @graken()
    def _numeric_test_(self):
        with self._choice():
            with self._option():
                self._num_compare_expression_()
            with self._option():
                self._numeric_is_number_()
            self._error('no available options')

    @graken()
    def _numeric_is_number_(self):
        self._propname_()
        self.ast['name'] = self.last_node
        self._token('is-#')

        self.ast._define(
            ['name'],
            []
        )

    @graken()
    def _num_compare_expression_(self):
        with self._choice():
            with self._option():
                self._equal_to_()
            with self._option():
                self._not_equal_to_()
            with self._option():
                self._less_than_()
            with self._option():
                self._greater_than_()
            with self._option():
                self._less_or_equal_()
            with self._option():
                self._greater_or_equal_()
            self._error('no available options')

    @graken()
    def _equal_to_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('==')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _not_equal_to_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('!=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _less_than_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('<')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _greater_than_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('>')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _less_or_equal_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('<=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _greater_or_equal_(self):
        self._num_expression_()
        self.ast['lhs'] = self.last_node
        self._token('>=')
        self._num_expression_()
        self.ast['rhs'] = self.last_node

        self.ast._define(
            ['lhs', 'rhs'],
            []
        )

    @graken()
    def _num_expression_(self):
        self._bitwise_expression_()

    @graken()
    def _bitwise_expression_(self):
        self._sum_expression_()
        self.ast['lhs'] = self.last_node

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('|')
                        with self._ifnot():
                            self._token('|')
                    with self._option():
                        self._token('&')
                        with self._ifnot():
                            self._token('&')
                    with self._option():
                        self._token('^')
                    self._error('expecting one of: & ^ |')
            self.ast['op'] = self.last_node
            self._sum_expression_()
            self.ast['rhs'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['lhs', 'op', 'rhs'],
            []
        )

    @graken()
    def _sum_expression_(self):
        self._mult_expression_()
        self.ast['lhs'] = self.last_node

        def block1():
            with self._group():
                with self._choice():
                    with self._option():
                        self._token('+')
                        with self._ifnot():
                            self._token('+')
                    with self._option():
                        self._token('-')
                    self._error('expecting one of: + -')
            self.ast['op'] = self.last_node
            self._mult_expression_()
            self.ast['rhs'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['lhs', 'op', 'rhs'],
            []
        )

    @graken()
    def _mult_expression_(self):
        self._factor_()
        self.ast['lhs'] = self.last_node

        def block1():
            self._mult_op_()
            self.ast['op'] = self.last_node
            self._factor_()
            self.ast['rhs'] = self.last_node
        self._closure(block1)

        self.ast._define(
            ['lhs', 'op', 'rhs'],
            []
        )

    @graken()
    def _factor_(self):
        with self._choice():
            with self._option():
                self._group_expression_()
                self.ast['value'] = self.last_node
            with self._option():
                self._number_()
                self.ast['value'] = self.last_node
            with self._option():
                self._varname_()
                self.ast['value'] = self.last_node
            self._error('no available options')

        self.ast._define(
            ['value'],
            []
        )

    @graken()
    def _group_expression_(self):
        self._token('(')
        self._num_expression_()
        self.ast['@'] = self.last_node
        self._token(')')

    @graken()
    def _mult_op_(self):
        with self._choice():
            with self._option():
                self._token('*')
            with self._option():
                self._token('/')
            with self._option():
                self._token('%')
            self._error('expecting one of: % * /')


class BroadwaySemantics(object):
    def start(self, ast):
        return ast

    def annotation(self, ast):
        return ast

    def header(self, ast):
        return ast

    def procedure(self, ast):
        return ast

    def procedure_annotation(self, ast):
        return ast

    def pointer_annotation(self, ast):
        return ast

    def cond_pointer_structure(self, ast):
        return ast

    def pointer_structure(self, ast):
        return ast

    def variable(self, ast):
        return ast

    def points_to(self, ast):
        return ast

    def struct(self, ast):
        return ast

    def delete(self, ast):
        return ast

    def dependence_annotation(self, ast):
        return ast

    def access(self, ast):
        return ast

    def modify(self, ast):
        return ast

    def property(self, ast):
        return ast

    def strong_property(self, ast):
        return ast

    def weak_property(self, ast):
        return ast

    def property_definition(self, ast):
        return ast

    def enum_property_definition(self, ast):
        return ast

    def direction(self, ast):
        return ast

    def forward(self, ast):
        return ast

    def backward(self, ast):
        return ast

    def initial_value(self, ast):
        return ast

    def property_values(self, ast):
        return ast

    def property_value_list(self, ast):
        return ast

    def property_value(self, ast):
        return ast

    def set_property_definition(self, ast):
        return ast

    def set_type(self, ast):
        return ast

    def analysis_rule_annotation(self, ast):
        return ast

    def analysis_rule(self, ast):
        return ast

    def if_(self, ast):
        return ast

    def default(self, ast):
        return ast

    def condition(self, ast):
        return ast

    def conjunction(self, ast):
        return ast

    def disjunction(self, ast):
        return ast

    def negation(self, ast):
        return ast

    def cond(self, ast):
        return ast

    def condition_group(self, ast):
        return ast

    def test(self, ast):
        return ast

    def enum_property_test(self, ast):
        return ast

    def enum_unknown_test(self, ast):
        return ast

    def enum_operator_test(self, ast):
        return ast

    def temporal_operator(self, ast):
        return ast

    def enum_property_operator(self, ast):
        return ast

    def set_property_test(self, ast):
        return ast

    def set_identifier_test(self, ast):
        return ast

    def set_element_test(self, ast):
        return ast

    def set_empty_test(self, ast):
        return ast

    def binding_test(self, ast):
        return ast

    def binding_alias_test(self, ast):
        return ast

    def binding_sameas_test(self, ast):
        return ast

    def binding_empty_test(self, ast):
        return ast

    def analysis_effect(self, ast):
        return ast

    def numeric_assignment(self, ast):
        return ast

    def enum_property_assignment(self, ast):
        return ast

    def enum_assignment(self, ast):
        return ast

    def enum_append(self, ast):
        return ast

    def set_property_operation(self, ast):
        return ast

    def add_operation(self, ast):
        return ast

    def remove_operation(self, ast):
        return ast

    def identifier_operation(self, ast):
        return ast

    def report_annotation(self, ast):
        return ast

    def report_conditional(self, ast):
        return ast

    def report_unconditional(self, ast):
        return ast

    def error_conditional(self, ast):
        return ast

    def error_unconditional(self, ast):
        return ast

    def report_element_list(self, ast):
        return ast

    def report_element(self, ast):
        return ast

    def report_property(self, ast):
        return ast

    def report_numeric(self, ast):
        return ast

    def report_identifier(self, ast):
        return ast

    def report_program_location(self, ast):
        return ast

    def callsite(self, ast):
        return ast

    def context(self, ast):
        return ast

    def action_annotation(self, ast):
        return ast

    def replace(self, ast):
        return ast

    def inline(self, ast):
        return ast

    def global_(self, ast):
        return ast

    def global_pointer(self, ast):
        return ast

    def identifier_list(self, ast):
        return ast

    def propname(self, ast):
        return ast

    def procname(self, ast):
        return ast

    def propval(self, ast):
        return ast

    def varname(self, ast):
        return ast

    def number(self, ast):
        return ast

    def string(self, ast):
        return ast

    def c_code(self, ast):
        return ast

    def identifier(self, ast):
        return ast

    def bottom_test(self, ast):
        return ast

    def exactly_test(self, ast):
        return ast

    def atleast_test(self, ast):
        return ast

    def could_be_test(self, ast):
        return ast

    def atmost_test(self, ast):
        return ast

    def numeric_test(self, ast):
        return ast

    def numeric_is_number(self, ast):
        return ast

    def num_compare_expression(self, ast):
        return ast

    def equal_to(self, ast):
        return ast

    def not_equal_to(self, ast):
        return ast

    def less_than(self, ast):
        return ast

    def greater_than(self, ast):
        return ast

    def less_or_equal(self, ast):
        return ast

    def greater_or_equal(self, ast):
        return ast

    def num_expression(self, ast):
        return ast

    def bitwise_expression(self, ast):
        return ast

    def sum_expression(self, ast):
        return ast

    def mult_expression(self, ast):
        return ast

    def factor(self, ast):
        return ast

    def group_expression(self, ast):
        return ast

    def mult_op(self, ast):
        return ast


def main(filename, startrule, trace=False, whitespace=None, nameguard=None):
    import json
    with open(filename) as f:
        text = f.read()
    parser = BroadwayParser(parseinfo=False)
    ast = parser.parse(
        text,
        startrule,
        filename=filename,
        trace=trace,
        whitespace=whitespace,
        nameguard=nameguard)
    print('AST:')
    print(ast)
    print()
    print('JSON:')
    print(json.dumps(ast, indent=2))
    print()

if __name__ == '__main__':
    import argparse
    import string
    import sys

    class ListRules(argparse.Action):
        def __call__(self, parser, namespace, values, option_string):
            print('Rules:')
            for r in BroadwayParser.rule_list():
                print(r)
            print()
            sys.exit(0)

    parser = argparse.ArgumentParser(description="Simple parser for Broadway.")
    parser.add_argument('-l', '--list', action=ListRules, nargs=0,
                        help="list all rules and exit")
    parser.add_argument('-n', '--no-nameguard', action='store_true',
                        dest='no_nameguard',
                        help="disable the 'nameguard' feature")
    parser.add_argument('-t', '--trace', action='store_true',
                        help="output trace information")
    parser.add_argument('-w', '--whitespace', type=str, default=string.whitespace,
                        help="whitespace specification")
    parser.add_argument('file', metavar="FILE", help="the input file to parse")
    parser.add_argument('startrule', metavar="STARTRULE",
                        help="the start rule for parsing")
    args = parser.parse_args()

    main(
        args.file,
        args.startrule,
        trace=args.trace,
        whitespace=args.whitespace,
        nameguard=not args.no_nameguard
    )
